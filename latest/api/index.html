<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>API - CUTEst.jl</title>
      
      
      
      
        <meta name="author" content="JuliaSmoothOptimizers">
      
    
    <meta property="og:url" content="None">
    <meta property="og:title" content="CUTEst.jl">
    <meta property="og:image" content="None/../">
    <meta name="apple-mobile-web-app-title" content="CUTEst.jl">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="../assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="../assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('../assets/fonts/icon.eot?52m981');
      	src: url('../assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('../assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('../assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('../assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="../assets/stylesheets/application-a422ff04cc.css">
    
      <link rel="stylesheet" href="../assets/stylesheets/palettes-05ab2406df.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu+Mono">
      <style>
        body, input {
          font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="../assets/Documenter.css">
    
      <link rel="stylesheet" href="../assets/style.css">
    
    <script src="../assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class="palette-primary-orange palette-accent-indigo">
    
      
      
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
          </span>
        
        API
      </div>
    </div>
    
    
      
      <div class="button button-github" role="button" aria-label="GitHub">
        <a href="https://github.com/JuliaSmoothOptimizers" title="@JuliaSmoothOptimizers on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
      </div>
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          CUTEst.jl
          <span class="version">
            
          </span>
        </strong>
        
          <br>
          JuliaSmoothOptimizers/CUTEst.jl
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            
            <a href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/JuliaSmoothOptimizers/CUTEst.jl/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="" title="Home" href="../home/">
      Home
    </a>
    
  </li>

          
            
  <li>
    <a class="current" title="API" href="./">
      API
    </a>
    
      
        
      
      
        <ul>
          
            <li class="anchor">
              <a title="NLPModels API" href="#nlpmodels-api">
                NLPModels API
              </a>
            </li>
          
            <li class="anchor">
              <a title="Extra julian API" href="#extra-julian-api">
                Extra julian API
              </a>
            </li>
          
            <li class="anchor">
              <a title="Core and specialized API" href="#core-and-specialized-api">
                Core and specialized API
              </a>
            </li>
          
            <li class="anchor">
              <a title="Internal" href="#internal">
                Internal
              </a>
            </li>
          
        </ul>
      
    
  </li>

          
            
  <li>
    <a class="" title="Index" href="..">
      Index
    </a>
    
  </li>

          
        </ul>
        
          <hr>
          <span class="section">The author</span>
          <ul>
            
            
              
              <li>
                <a href="https://github.com/JuliaSmoothOptimizers" target="_blank" title="@JuliaSmoothOptimizers on GitHub">
                  @JuliaSmoothOptimizers on GitHub
                </a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
          <p><a id='API-1'></a></p>
<h1 id="api">API</h1>
<p><a id='NLPModels-API-1'></a></p>
<h2 id="nlpmodels-api">NLPModels API</h2>
<p><a id='NLPModels.obj' href='#NLPModels.obj'>#</a>
<strong><code>NLPModels.obj</code></strong> &mdash; <em>Function</em>.</p>
<p><code>obj(nlp, x)</code></p>
<p>Evaluate $f(x)$, the objective function of <code>nlp</code> at <code>x</code>.</p>
<p><a id='NLPModels.grad' href='#NLPModels.grad'>#</a>
<strong><code>NLPModels.grad</code></strong> &mdash; <em>Function</em>.</p>
<p><code>grad(nlp, x)</code></p>
<p>Evaluate $\nabla f(x)$, the gradient of the objective function at <code>x</code>.</p>
<p><a id='NLPModels.grad!' href='#NLPModels.grad!'>#</a>
<strong><code>NLPModels.grad!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>grad!(nlp, x, g)</code></p>
<p>Evaluate $\nabla f(x)$, the gradient of the objective function at <code>x</code> in place.</p>
<p><a id='NLPModels.cons' href='#NLPModels.cons'>#</a>
<strong><code>NLPModels.cons</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>cons(nlp, x, jac)
</code></pre>

<p>Computes the constraint vector and, if <code>jac</code> is <code>true</code>, the Jacobian in internal sparse format. Usage:</p>
<pre><code>c, J = cons(nlp, x, true)
c = cons(nlp, x, false)
</code></pre>

<ul>
<li>nlp:  [IN] CUTEstModel</li>
<li>x:    [IN] Array{Float64, 1}</li>
<li>jac:  [IN] Bool</li>
<li>c:    [OUT] Array{Float64, 1}</li>
<li>J:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}</li>
</ul>
<p><code>cons(nlp, x)</code></p>
<p>Evaluate $c(x)$, the constraints at <code>x</code>.</p>
<p><a id='NLPModels.cons!' href='#NLPModels.cons!'>#</a>
<strong><code>NLPModels.cons!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>cons!(nlp, x, c)</code></p>
<p>Evaluate $c(x)$, the constraints at <code>x</code> in place.</p>
<p><a id='NLPModels.jac_coord' href='#NLPModels.jac_coord'>#</a>
<strong><code>NLPModels.jac_coord</code></strong> &mdash; <em>Function</em>.</p>
<p><code>(rows,cols,vals) = jac_coord(nlp, x)</code></p>
<p>Evaluate $\nabla c(x)$, the constraint's Jacobian at <code>x</code> in sparse coordinate format.</p>
<p><a id='NLPModels.jac' href='#NLPModels.jac'>#</a>
<strong><code>NLPModels.jac</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Jx = jac(nlp, x)</code></p>
<p>Evaluate $\nabla c(x)$, the constraint's Jacobian at <code>x</code> as a sparse matrix.</p>
<p><a id='NLPModels.jprod' href='#NLPModels.jprod'>#</a>
<strong><code>NLPModels.jprod</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Jv = jprod(nlp, x, v)</code></p>
<p>Evaluate $\nabla c(x)v$, the Jacobian-vector product at <code>x</code>.</p>
<p><a id='NLPModels.jprod!' href='#NLPModels.jprod!'>#</a>
<strong><code>NLPModels.jprod!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Jv = jprod!(nlp, x, v, Jv)</code></p>
<p>Evaluate $\nabla c(x)v$, the Jacobian-vector product at <code>x</code> in place.</p>
<p><a id='NLPModels.jtprod' href='#NLPModels.jtprod'>#</a>
<strong><code>NLPModels.jtprod</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Jtv = jtprod(nlp, x, v, Jtv)</code></p>
<p>Evaluate $\nabla c(x)^Tv$, the transposed-Jacobian-vector product at <code>x</code>.</p>
<p><a id='NLPModels.jtprod!' href='#NLPModels.jtprod!'>#</a>
<strong><code>NLPModels.jtprod!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Jtv = jtprod!(nlp, x, v, Jtv)</code></p>
<p>Evaluate $\nabla c(x)^Tv$, the transposed-Jacobian-vector product at <code>x</code> in place.</p>
<p><a id='NLPModels.hess_coord' href='#NLPModels.hess_coord'>#</a>
<strong><code>NLPModels.hess_coord</code></strong> &mdash; <em>Function</em>.</p>
<p><code>(rows,cols,vals) = hess_coord(nlp, x; obj_weight=1.0, y=zeros)</code></p>
<p>Evaluate the Lagrangian Hessian at <code>(x,y)</code> in sparse coordinate format, with objective function scaled by <code>obj_weight</code>, i.e.,</p>
<p>
<script type="math/tex; mode=display"> \nabla^2L(x,y) = \sigma * \nabla^2 f(x) + \sum_{i=1}^m y_i\nabla^2 c_i(x), </script>
</p>
<p>with σ = obj_weight. Only the lower triangle is returned.</p>
<p><a id='NLPModels.hess' href='#NLPModels.hess'>#</a>
<strong><code>NLPModels.hess</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Hx = hess(nlp, x; obj_weight=1.0, y=zeros)</code></p>
<p>Evaluate the Lagrangian Hessian at <code>(x,y)</code> as a sparse matrix, with objective function scaled by <code>obj_weight</code>, i.e.,</p>
<p>
<script type="math/tex; mode=display"> \nabla^2L(x,y) = \sigma * \nabla^2 f(x) + \sum_{i=1}^m y_i\nabla^2 c_i(x), </script>
</p>
<p>with σ = obj_weight. Only the lower triangle is returned.</p>
<p><a id='NLPModels.hprod' href='#NLPModels.hprod'>#</a>
<strong><code>NLPModels.hprod</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Hv = hprod(nlp, x, v; obj_weight=1.0, y=zeros)</code></p>
<p>Evaluate the product of the Lagrangian Hessian at <code>(x,y)</code> with the vector <code>v</code>, with objective function scaled by <code>obj_weight</code>, i.e.,</p>
<p>
<script type="math/tex; mode=display"> \nabla^2L(x,y) = \sigma * \nabla^2 f(x) + \sum_{i=1}^m y_i\nabla^2 c_i(x), </script>
</p>
<p>with σ = obj_weight.</p>
<p><a id='NLPModels.hprod!' href='#NLPModels.hprod!'>#</a>
<strong><code>NLPModels.hprod!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>Hv = hprod!(nlp, x, v, Hv; obj_weight=1.0, y=zeros)</code></p>
<p>Evaluate the product of the Lagrangian Hessian at <code>(x,y)</code> with the vector <code>v</code> in place, with objective function scaled by <code>obj_weight</code>, i.e.,</p>
<p>
<script type="math/tex; mode=display"> \nabla^2L(x,y) = \sigma * \nabla^2 f(x) + \sum_{i=1}^m y_i\nabla^2 c_i(x), </script>
</p>
<p>with σ = obj_weight.</p>
<p><a id='NLPModels.NLPtoMPB' href='#NLPModels.NLPtoMPB'>#</a>
<strong><code>NLPModels.NLPtoMPB</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>mp = NLPtoMPB(nlp, solver)
</code></pre>

<p>Return a <code>MathProgBase</code> model corresponding to an <code>AbstractNLPModel</code>.</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>nlp::AbstractNLPModel</code></li>
<li><code>solver::AbstractMathProgSolver</code> a solver instance, e.g., <code>IpoptSolver()</code></li>
</ul>
<p>Currently, all models are treated as nonlinear models.</p>
<p><strong>Return values</strong></p>
<p>The function returns a <code>MathProgBase</code> model <code>mpbmodel</code> such that it should be possible to call</p>
<pre><code>MathProgBase.optimize!(mpbmodel)
</code></pre>

<p><a id='NLPModels.reset!' href='#NLPModels.reset!'>#</a>
<strong><code>NLPModels.reset!</code></strong> &mdash; <em>Function</em>.</p>
<p><code>reset!(counters)</code></p>
<p>Reset evaluation counters</p>
<p>`reset!(nlp)</p>
<p>Reset evaluation count in <code>nlp</code></p>
<p><a id='Extra-julian-API-1'></a></p>
<h2 id="extra-julian-api">Extra julian API</h2>
<p><a id='CUTEst.objgrad' href='#CUTEst.objgrad'>#</a>
<strong><code>CUTEst.objgrad</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>objgrad(nlp, x, grad)
</code></pre>

<p>Computes the objective function value and, if grad is <code>true</code>, gradient at x. Usage:</p>
<pre><code>f, g = objgrad(nlp, x, true)
f = objgrad(nlp, x)
</code></pre>

<ul>
<li>nlp:  [IN] CUTEstModel</li>
<li>x:    [IN] Array{Float64, 1}</li>
<li>grad: [IN] Bool</li>
<li>f:    [OUT] Float64</li>
<li>g:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.objcons' href='#CUTEst.objcons'>#</a>
<strong><code>CUTEst.objcons</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>objcons(nlp, x)
</code></pre>

<p>Computes the objective function and constraint vector values at x. Usage:</p>
<pre><code>f, c = objcons(nlp, x) # If the problem is constrained
f = objcons(nlp, x)    # If the problem is unconstrained
</code></pre>

<ul>
<li>nlp: [IN] CUTEstModel</li>
<li>x:   [IN] Array{Float64, 1}</li>
<li>f:   [OUT] Float64</li>
<li>c:   [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cons_coord' href='#CUTEst.cons_coord'>#</a>
<strong><code>CUTEst.cons_coord</code></strong> &mdash; <em>Function</em>.</p>
<pre><code>cons_coord(nlp, x, jac)
</code></pre>

<p>Computes the constraint vector and, if <code>jac</code> is <code>true</code>, the Jacobian in coordinate format. Usage:</p>
<pre><code>c, jrow, jcol, jval = cons_coord(nlp, x, true)
c = cons_coord(nlp, x, false)
</code></pre>

<ul>
<li>nlp:  [IN] CUTEstModel</li>
<li>x:    [IN] Array{Float64, 1}</li>
<li>jac:  [IN] Bool</li>
<li>c:    [OUT] Array{Float64, 1}</li>
<li>jrow: [OUT] Array{Int32, 1}</li>
<li>jcol: [OUT] Array{Int32, 1}</li>
<li>jval: [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='Core-and-specialized-API-1'></a></p>
<h2 id="core-and-specialized-api">Core and specialized API</h2>
<p><a id='CUTEst.ccfg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2},Array{Int32,1}}' href='#CUTEst.ccfg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ccfg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ccfg</strong></p>
<p>The ccfg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ccfg
</code></pre>

<p>Usage:</p>
<pre><code>ccfg(io_err, n, m, x, c, jtrans, lcjac1, lcjac2, cjac, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>c:       [OUT] Array{Cdouble, 1}</li>
<li>jtrans:  [IN] Array{Cint, 1}</li>
<li>lcjac1:  [IN] Array{Cint, 1}</li>
<li>lcjac2:  [IN] Array{Cint, 1}</li>
<li>cjac:    [OUT] Array{Cdouble, 2}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ccfsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ccfsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ccfsg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ccfsg</strong></p>
<p>The ccfsg subroutine evaluates the values of the constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly their gradients in the constrained minimization case. The gradients are stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ccfsg
</code></pre>

<p>Usage:</p>
<pre><code>ccfsg(io_err, n, m, x, c, nnzj, lj, j_val, j_var, j_fun, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>c:       [OUT] Array{Cdouble, 1}</li>
<li>nnzj:    [OUT] Array{Cint, 1}</li>
<li>lj:      [IN] Array{Cint, 1}</li>
<li>j_val:   [OUT] Array{Cdouble, 1}</li>
<li>j_var:   [OUT] Array{Cint, 1}</li>
<li>j_fun:   [OUT] Array{Cint, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cchprods-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cchprods-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cchprods</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cchprods</strong></p>
<p>The cchprods subroutine forms the product of a vector with each of the Hessian matrix of the constraint functions c(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point x= X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cchprods
</code></pre>

<p>Usage:</p>
<pre><code>cchprods(io_err, n, m, goth, x, vector, lchp, chp_val, chp_ind, chp_ptr)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>goth:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>vector:  [IN] Array{Cdouble, 1}</li>
<li>lchp:    [IN] Array{Cint, 1}</li>
<li>chp_val: [OUT] Array{Cdouble, 1}</li>
<li>chp_ind: [IN] Array{Cint, 1}</li>
<li>chp_ptr: [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ccifg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.ccifg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ccifg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ccifg</strong></p>
<p>The ccifg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ccifg
</code></pre>

<p>Usage:</p>
<pre><code>ccifg(io_err, n, icon, x, ci, gci, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>icon:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>ci:      [OUT] Array{Cdouble, 1}</li>
<li>gci:     [OUT] Array{Cdouble, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ccifsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ccifsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ccifsg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ccifsg</strong></p>
<p>The ccifsg subroutine evaluates the value of a particular constraint function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in the constrained minimization case. The gradient is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ccifsg
</code></pre>

<p>Usage:</p>
<pre><code>ccifsg(io_err, n, icon, x, ci, nnzgci, lgci, gci_val, gci_var, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>icon:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>ci:      [OUT] Array{Cdouble, 1}</li>
<li>nnzgci:  [OUT] Array{Cint, 1}</li>
<li>lgci:    [IN] Array{Cint, 1}</li>
<li>gci_val: [OUT] Array{Cdouble, 1}</li>
<li>gci_var: [OUT] Array{Cint, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.cdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdh</strong></p>
<p>The cdh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdh
</code></pre>

<p>Usage:</p>
<pre><code>cdh(io_err, n, m, x, y, lh1, h_val)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.cdhc-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.cdhc-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdhc</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdhc</strong></p>
<p>The cdhc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdhc
</code></pre>

<p>Usage:</p>
<pre><code>cdhc(io_err, n, m, x, y, lh1, h_val)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.cdimchp-Tuple{Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cdimchp-Tuple{Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cdimchp</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdimchp</strong></p>
<p>The cdimchp subroutine determines the number of nonzero elements required to store the products of the Hessian matrices of the constraint functions with a specified vector for the problem decoded into OUTSDIF.d in the constrained minimization case. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdimchp
</code></pre>

<p>Usage:</p>
<pre><code>cdimchp(io_err, nnzchp)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>nnzchp:  [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cdimen-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cdimen-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cdimen</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdimen</strong></p>
<p>The cdimen subroutine discovers how many variables and constraints are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdimen
</code></pre>

<p>Usage:</p>
<pre><code>cdimen(io_err, input, n, m)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>input:   [IN] Array{Cint, 1}</li>
<li>n:       [OUT] Array{Cint, 1}</li>
<li>m:       [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cdimse-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cdimse-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cdimse</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdimse</strong></p>
<p>The cdimse subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded from a SIF file by the script sifdecoder. The matrix is stored in sparse "finite element" format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdimse
</code></pre>

<p>Usage:</p>
<pre><code>cdimse(io_err, ne, he_val_ne, he_row_ne)
</code></pre>

<ul>
<li>io_err:    [OUT] Array{Cint, 1}</li>
<li>ne:        [OUT] Array{Cint, 1}</li>
<li>he_val_ne: [OUT] Array{Cint, 1}</li>
<li>he_row_ne: [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cdimsh-Tuple{Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cdimsh-Tuple{Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cdimsh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdimsh</strong></p>
<p>The cdimsh subroutine determines the number of nonzero elements required to store the Hessian matrix of the Lagrangian function for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse "coordinate" format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdimsh
</code></pre>

<p>Usage:</p>
<pre><code>cdimsh(io_err, nnzh)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cdimsj-Tuple{Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cdimsj-Tuple{Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cdimsj</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cdimsj</strong></p>
<p>The cdimsj subroutine determines the number of nonzero elements required to store the matrix of gradients of the objective function and constraint functions for the problem decoded into OUTSDIF.d in the constrained minimization case. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cdimsj
</code></pre>

<p>Usage:</p>
<pre><code>cdimsj(io_err, nnzj)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>nnzj:    [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ceh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.ceh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ceh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ceh</strong></p>
<p>The ceh subroutine evaluates the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ceh
</code></pre>

<p>Usage:</p>
<pre><code>ceh(io_err, n, m, x, y, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row,
</code></pre>

<p>he_row, lhe_val, he_val, byrows)</p>
<ul>
<li>io_err:     [OUT] Array{Cint, 1}</li>
<li>n:          [IN] Array{Cint, 1}</li>
<li>m:          [IN] Array{Cint, 1}</li>
<li>x:          [IN] Array{Cdouble, 1}</li>
<li>y:          [IN] Array{Cdouble, 1}</li>
<li>ne:         [OUT] Array{Cint, 1}</li>
<li>lhe_ptr:    [IN] Array{Cint, 1}</li>
<li>he_row_ptr: [OUT] Array{Cint, 1}</li>
<li>he_val_ptr: [OUT] Array{Cint, 1}</li>
<li>lhe_row:    [IN] Array{Cint, 1}</li>
<li>he_row:     [OUT] Array{Cint, 1}</li>
<li>lhe_val:    [IN] Array{Cint, 1}</li>
<li>he_val:     [OUT] Array{Cdouble, 1}</li>
<li>byrows:     [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cfn-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.cfn-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cfn</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cfn</strong></p>
<p>The cfn subroutine evaluates the value of the objective function and general constraint functions of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cfn
</code></pre>

<p>Usage:</p>
<pre><code>cfn(io_err, n, m, x, f, c)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
<li>c:       [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.cgr-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.cgr-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgr</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cgr</strong></p>
<p>The cgr subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cgr
</code></pre>

<p>Usage:</p>
<pre><code>cgr(io_err, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>grlagf:  [IN] Array{Cint, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>jtrans:  [IN] Array{Cint, 1}</li>
<li>lj1:     [IN] Array{Cint, 1}</li>
<li>lj2:     [IN] Array{Cint, 1}</li>
<li>j_val:   [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.cgrdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.cgrdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,2},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgrdh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cgrdh</strong></p>
<p>The cgrdh subroutine evaluates the gradients of the general constraints and of either the objective function f(x) or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients and matrices are stored in a dense format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cgrdh
</code></pre>

<p>Usage:</p>
<pre><code>cgrdh(io_err, n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val, lh1, h_val)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>grlagf:  [IN] Array{Cint, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>jtrans:  [IN] Array{Cint, 1}</li>
<li>lj1:     [IN] Array{Cint, 1}</li>
<li>lj2:     [IN] Array{Cint, 1}</li>
<li>j_val:   [OUT] Array{Cdouble, 2}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.chcprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chcprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chcprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>chcprod</strong></p>
<p>The chcprod subroutine forms the product of a vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) of the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_chcprod
</code></pre>

<p>Usage:</p>
<pre><code>chcprod(io_err, n, m, goth, x, y, vector, result)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>goth:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>vector:  [IN] Array{Cdouble, 1}</li>
<li>result:  [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.chprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>chprod</strong></p>
<p>The chprod subroutine forms the product of a vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_chprod
</code></pre>

<p>Usage:</p>
<pre><code>chprod(io_err, n, m, goth, x, y, vector, result)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>goth:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>vector:  [IN] Array{Cdouble, 1}</li>
<li>result:  [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.cidh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.cidh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cidh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cidh</strong></p>
<p>The cidh subroutine evaluates the Hessian matrix of either the objective function or a constraint function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cidh
</code></pre>

<p>Usage:</p>
<pre><code>cidh(io_err, n, x, iprob, lh1, h)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>iprob:   [IN] Array{Cint, 1}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h:       [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.cish-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cish-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cish</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cish</strong></p>
<p>The cish subroutine evaluates the Hessian of a particular constraint function or the objective function for the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cish
</code></pre>

<p>Usage:</p>
<pre><code>cish(io_err, n, x, iprob, nnzh, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>iprob:   [IN] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cjprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.cjprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cjprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cjprod</strong></p>
<p>The cjprod subroutine forms the product of a vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cjprod
</code></pre>

<p>Usage:</p>
<pre><code>cjprod(io_err, n, m, gotj, jtrans, x, vector, lvector, result, lresult)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>gotj:    [IN] Array{Cint, 1}</li>
<li>jtrans:  [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>vector:  [IN] Array{Cdouble, 1}</li>
<li>lvector: [IN] Array{Cint, 1}</li>
<li>result:  [OUT] Array{Cdouble, 1}</li>
<li>lresult: [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.clfg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.clfg-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.clfg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>clfg</strong></p>
<p>The clfg subroutine evaluates the value of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (X,Y), and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_clfg
</code></pre>

<p>Usage:</p>
<pre><code>clfg(io_err, n, m, x, y, f, g, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cnames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int8,1},Array{Int8,1},Array{Int8,1}}' href='#CUTEst.cnames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int8,1},Array{Int8,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.cnames</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cnames</strong></p>
<p>The cnames subroutine obtains the names of the problem, its variables and general constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cnames
</code></pre>

<p>Usage:</p>
<pre><code>cnames(io_err, n, m, pname, vname, cname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>pname:   [OUT] Array{Cchar, 1}</li>
<li>vname:   [OUT] Array{Cchar, 1}</li>
<li>cname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.cofg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.cofg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cofg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cofg</strong></p>
<p>The cofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cofg
</code></pre>

<p>Usage:</p>
<pre><code>cofg(io_err, n, x, f, g, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cofsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cofsg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cofsg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cofsg</strong></p>
<p>The cofsg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cofsg
</code></pre>

<p>Usage:</p>
<pre><code>cofsg(io_err, n, x, f, nnzg, lg, g_val, g_var, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
<li>nnzg:    [OUT] Array{Cint, 1}</li>
<li>lg:      [IN] Array{Cint, 1}</li>
<li>g_val:   [OUT] Array{Cdouble, 1}</li>
<li>g_var:   [OUT] Array{Cint, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.connames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}' href='#CUTEst.connames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.connames</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>connames</strong></p>
<p>The connames subroutine obtains the names of the general constraints of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_connames
</code></pre>

<p>Usage:</p>
<pre><code>connames(io_err, m, cname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>cname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.creport-Tuple{Array{Int32,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.creport-Tuple{Array{Int32,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.creport</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>creport</strong></p>
<p>The creport subroutine obtains statistics concerning function evaluation and CPU time used for constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_creport
</code></pre>

<p>Usage:</p>
<pre><code>creport(io_err, calls, time)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>calls:   [OUT] Array{Cdouble, 1}</li>
<li>time:    [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.csetup-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.csetup-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csetup</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csetup</strong></p>
<p>The csetup subroutine sets up the correct data structures for subsequent computations on the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csetup
</code></pre>

<p>Usage:</p>
<pre><code>csetup(io_err, input, out, io_buffer, n, m, x, x_l, x_u, y, c_l, c_u, equatn,
</code></pre>

<p>linear, e_order, l_order, v_order)</p>
<ul>
<li>io_err:    [OUT] Array{Cint, 1}</li>
<li>input:     [IN] Array{Cint, 1}</li>
<li>out:       [IN] Array{Cint, 1}</li>
<li>io_buffer: [IN] Array{Cint, 1}</li>
<li>n:         [IN] Array{Cint, 1}</li>
<li>m:         [IN] Array{Cint, 1}</li>
<li>x:         [OUT] Array{Cdouble, 1}</li>
<li>x_l:       [OUT] Array{Cdouble, 1}</li>
<li>x_u:       [OUT] Array{Cdouble, 1}</li>
<li>y:         [OUT] Array{Cdouble, 1}</li>
<li>c_l:       [OUT] Array{Cdouble, 1}</li>
<li>c_u:       [OUT] Array{Cdouble, 1}</li>
<li>equatn:    [OUT] Array{Cint, 1}</li>
<li>linear:    [OUT] Array{Cint, 1}</li>
<li>e_order:   [IN] Array{Cint, 1}</li>
<li>l_order:   [IN] Array{Cint, 1}</li>
<li>v_order:   [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.csgr-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.csgr-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csgr</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csgr</strong></p>
<p>The csgr subroutine evaluates the gradients of the general constraints and of either the objective function or the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). It also evaluates the Hessian matrix of the Lagrangian function at (x,y). The gradients are stored in a sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csgr
</code></pre>

<p>Usage:</p>
<pre><code>csgr(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>grlagf:  [IN] Array{Cint, 1}</li>
<li>nnzj:    [OUT] Array{Cint, 1}</li>
<li>lj:      [IN] Array{Cint, 1}</li>
<li>j_val:   [OUT] Array{Cdouble, 1}</li>
<li>j_var:   [OUT] Array{Cint, 1}</li>
<li>j_fun:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.csgreh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.csgreh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csgreh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csgreh</strong></p>
<p>The csgreh subroutine evaluates both the gradients of the general constraint functions and the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded into OUTSDIF.d at the point (x,y)= (X,Y). This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The subroutine also obtains the gradient of either the objective function or the Lagrangian function, stored in a sparse format. The problem under consideration consists in minimizing (or maximizing) an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csgreh
</code></pre>

<p>Usage:</p>
<pre><code>csgreh(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, ne,
</code></pre>

<p>lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)</p>
<ul>
<li>io_err:     [OUT] Array{Cint, 1}</li>
<li>n:          [IN] Array{Cint, 1}</li>
<li>m:          [IN] Array{Cint, 1}</li>
<li>x:          [IN] Array{Cdouble, 1}</li>
<li>y:          [IN] Array{Cdouble, 1}</li>
<li>grlagf:     [IN] Array{Cint, 1}</li>
<li>nnzj:       [OUT] Array{Cint, 1}</li>
<li>lj:         [IN] Array{Cint, 1}</li>
<li>j_val:      [OUT] Array{Cdouble, 1}</li>
<li>j_var:      [OUT] Array{Cint, 1}</li>
<li>j_fun:      [OUT] Array{Cint, 1}</li>
<li>ne:         [OUT] Array{Cint, 1}</li>
<li>lhe_ptr:    [IN] Array{Cint, 1}</li>
<li>he_row_ptr: [OUT] Array{Cint, 1}</li>
<li>he_val_ptr: [OUT] Array{Cint, 1}</li>
<li>lhe_row:    [IN] Array{Cint, 1}</li>
<li>he_row:     [OUT] Array{Cint, 1}</li>
<li>lhe_val:    [IN] Array{Cint, 1}</li>
<li>he_val:     [OUT] Array{Cdouble, 1}</li>
<li>byrows:     [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.csgrsh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.csgrsh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csgrsh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csgrsh</strong></p>
<p>The csgrsh subroutine evaluates the gradients of the general constraints, the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) and the gradient of either the objective function or the Lagrangian corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The data is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csgrsh
</code></pre>

<p>Usage:</p>
<pre><code>csgrsh(io_err, n, m, x, y, grlagf, nnzj, lj, j_val, j_var, j_fun, nnzh, lh,
</code></pre>

<p>h_val, h_row, h_col)</p>
<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>grlagf:  [IN] Array{Cint, 1}</li>
<li>nnzj:    [OUT] Array{Cint, 1}</li>
<li>lj:      [IN] Array{Cint, 1}</li>
<li>j_val:   [OUT] Array{Cdouble, 1}</li>
<li>j_var:   [OUT] Array{Cint, 1}</li>
<li>j_fun:   [OUT] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.csh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.csh-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csh</strong></p>
<p>The csh subroutine evaluates the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csh
</code></pre>

<p>Usage:</p>
<pre><code>csh(io_err, n, m, x, y, nnzh, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cshc-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cshc-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cshc</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cshc</strong></p>
<p>The cshc subroutine evaluates the Hessian matrix of the constraint part of the Lagrangian function yTc(x) for the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The matrix is stored in sparse format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cshc
</code></pre>

<p>Usage:</p>
<pre><code>cshc(io_err, n, m, x, y, nnzh, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>m:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>y:       [IN] Array{Cdouble, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cshcprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}' href='#CUTEst.cshcprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshcprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cshcprod</strong></p>
<p>The cshcprod subroutine forms the product of a sparse vector with the Hessian matrix of the constraint part of the Lagrangian function yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cshcprod
</code></pre>

<p>Usage:</p>
<pre><code>cshcprod(io_err, n, m, goth, x, y, nnz_vector, index_nz_vector, vector,
</code></pre>

<p>nnz_result, index_nz_result, result)</p>
<ul>
<li>io_err:          [OUT] Array{Cint, 1}</li>
<li>n:               [IN] Array{Cint, 1}</li>
<li>m:               [IN] Array{Cint, 1}</li>
<li>goth:            [IN] Array{Cint, 1}</li>
<li>x:               [IN] Array{Cdouble, 1}</li>
<li>y:               [IN] Array{Cdouble, 1}</li>
<li>nnz_vector:      [IN] Array{Cint, 1}</li>
<li>index_nz_vector: [IN] Array{Cint, 1}</li>
<li>vector:          [IN] Array{Cdouble, 1}</li>
<li>nnz_result:      [OUT] Array{Cint, 1}</li>
<li>index_nz_result: [OUT] Array{Cint, 1}</li>
<li>result:          [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.cshp-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cshp-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cshp</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cshp</strong></p>
<p>The cshp subroutine evaluates the sparsity pattern of the Hessian of the Lagrangian function l(x,y)=f(x)+yTc(x) for the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cshp
</code></pre>

<p>Usage:</p>
<pre><code>cshp(io_err, n, nnzh, lh, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cshprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}' href='#CUTEst.cshprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cshprod</strong></p>
<p>The cshprod subroutine forms the product of a sparse vector with the Hessian matrix of the Lagrangian function l(x,y)=f(x)+yTc(x) corresponding to the problem decoded from a SIF file by the script sifdecoder at the point (x,y)= (X,Y). The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cshprod
</code></pre>

<p>Usage:</p>
<pre><code>cshprod(io_err, n, m, goth, x, y, nnz_vector, index_nz_vector, vector,
</code></pre>

<p>nnz_result, index_nz_result, result)</p>
<ul>
<li>io_err:          [OUT] Array{Cint, 1}</li>
<li>n:               [IN] Array{Cint, 1}</li>
<li>m:               [IN] Array{Cint, 1}</li>
<li>goth:            [IN] Array{Cint, 1}</li>
<li>x:               [IN] Array{Cdouble, 1}</li>
<li>y:               [IN] Array{Cdouble, 1}</li>
<li>nnz_vector:      [IN] Array{Cint, 1}</li>
<li>index_nz_vector: [IN] Array{Cint, 1}</li>
<li>vector:          [IN] Array{Cdouble, 1}</li>
<li>nnz_result:      [OUT] Array{Cint, 1}</li>
<li>index_nz_result: [OUT] Array{Cint, 1}</li>
<li>result:          [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.csjprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.csjprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.csjprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>csjprod</strong></p>
<p>The csjprod subroutine forms the product of a sparse vector with the Jacobian matrix, or with its transpose, of the constraint functions of the problem decoded from a SIF file by the script sifdecoder evaluated at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_csjprod
</code></pre>

<p>Usage:</p>
<pre><code>csjprod(io_err, n, m, gotj, jtrans, x, nnz_vector, index_nz_vector, vector,
</code></pre>

<p>lvector, nnz_result, index_nz_result, result, lresult)</p>
<ul>
<li>io_err:          [OUT] Array{Cint, 1}</li>
<li>n:               [IN] Array{Cint, 1}</li>
<li>m:               [IN] Array{Cint, 1}</li>
<li>gotj:            [IN] Array{Cint, 1}</li>
<li>jtrans:          [IN] Array{Cint, 1}</li>
<li>x:               [IN] Array{Cdouble, 1}</li>
<li>nnz_vector:      [IN] Array{Cint, 1}</li>
<li>index_nz_vector: [IN] Array{Cint, 1}</li>
<li>vector:          [IN] Array{Cdouble, 1}</li>
<li>lvector:         [IN] Array{Cint, 1}</li>
<li>nnz_result:      [OUT] Array{Cint, 1}</li>
<li>index_nz_result: [OUT] Array{Cint, 1}</li>
<li>result:          [OUT] Array{Cdouble, 1}</li>
<li>lresult:         [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cstats-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cstats-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cstats</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cstats</strong></p>
<pre><code>cstats(io_err, nonlinear_variables_objective,
</code></pre>

<p>nonlinear_variables_constraints, equality_constraints, linear_constraints)</p>
<ul>
<li>io_err:                          [OUT] Array{Cint, 1}</li>
<li>nonlinear_variables_objective:   [OUT] Array{Cint, 1}</li>
<li>nonlinear_variables_constraints: [OUT] Array{Cint, 1}</li>
<li>equality_constraints:            [OUT] Array{Cint, 1}</li>
<li>linear_constraints:              [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cterminate-Tuple{Array{Int32,1}}' href='#CUTEst.cterminate-Tuple{Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cterminate</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cterminate</strong></p>
<p>The uterminate subroutine deallocates all workspace arrays created since the last call to csetup.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cterminate
</code></pre>

<p>Usage:</p>
<pre><code>cterminate(io_err)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.cvartype-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.cvartype-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.cvartype</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>cvartype</strong></p>
<p>The cvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_cvartype
</code></pre>

<p>Usage:</p>
<pre><code>cvartype(io_err, n, x_type)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x_type:  [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.pname-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}' href='#CUTEst.pname-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.pname</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>pname</strong></p>
<p>The pname subroutine obtains the name of the problem directly from the datafile OUTSDIF.d that was created by the script sifdecoder when decoding a SIF file. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_pname
</code></pre>

<p>Usage:</p>
<pre><code>pname(io_err, input, pname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>input:   [IN] Array{Cint, 1}</li>
<li>pname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.probname-Tuple{Array{Int32,1},Array{Int8,1}}' href='#CUTEst.probname-Tuple{Array{Int32,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.probname</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>probname</strong></p>
<p>The probname subroutine obtains the name of the problem. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_probname
</code></pre>

<p>Usage:</p>
<pre><code>probname(io_err, pname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>pname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.ubandh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Float64,2},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ubandh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Float64,2},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ubandh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ubandh</strong></p>
<p>The ubandh subroutine extracts the elements which lie within a band of given semi-bandwidth out of the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ubandh
</code></pre>

<p>Usage:</p>
<pre><code>ubandh(io_err, n, x, semibandwidth, h_band, lbandh, max_semibandwidth)
</code></pre>

<ul>
<li>io_err:            [OUT] Array{Cint, 1}</li>
<li>n:                 [IN] Array{Cint, 1}</li>
<li>x:                 [IN] Array{Cdouble, 1}</li>
<li>semibandwidth:     [IN] Array{Cint, 1}</li>
<li>h_band:            [OUT] Array{Cdouble, 2}</li>
<li>lbandh:            [IN] Array{Cint, 1}</li>
<li>max_semibandwidth: [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.udh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.udh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.udh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>udh</strong></p>
<p>The udh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_udh
</code></pre>

<p>Usage:</p>
<pre><code>udh(io_err, n, x, lh1, h)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h:       [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.udimen-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.udimen-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.udimen</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>udimen</strong></p>
<p>The udimen subroutine discovers how many variables are involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_udimen
</code></pre>

<p>Usage:</p>
<pre><code>udimen(io_err, input, n)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>input:   [IN] Array{Cint, 1}</li>
<li>n:       [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.udimse-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.udimse-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.udimse</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>udimse</strong></p>
<p>The udimse subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H_i involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_udimse
</code></pre>

<p>Usage:</p>
<pre><code>udimse(io_err, ne, he_val_ne, he_row_ne)
</code></pre>

<ul>
<li>io_err:    [OUT] Array{Cint, 1}</li>
<li>ne:        [OUT] Array{Cint, 1}</li>
<li>he_val_ne: [OUT] Array{Cint, 1}</li>
<li>he_row_ne: [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.udimsh-Tuple{Array{Int32,1},Array{Int32,1}}' href='#CUTEst.udimsh-Tuple{Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.udimsh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>udimsh</strong></p>
<p>The udimsh subroutine determine the number of nonzeros required to store the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_udimsh
</code></pre>

<p>Usage:</p>
<pre><code>udimsh(io_err, nnzh)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ueh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.ueh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ueh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ueh</strong></p>
<p>The ueh subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element He involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ueh
</code></pre>

<p>Usage:</p>
<pre><code>ueh(io_err, n, x, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row,
</code></pre>

<p>lhe_val, he_val, byrows)</p>
<ul>
<li>io_err:     [OUT] Array{Cint, 1}</li>
<li>n:          [IN] Array{Cint, 1}</li>
<li>x:          [IN] Array{Cdouble, 1}</li>
<li>ne:         [OUT] Array{Cint, 1}</li>
<li>lhe_ptr:    [IN] Array{Cint, 1}</li>
<li>he_row_ptr: [OUT] Array{Cint, 1}</li>
<li>he_val_ptr: [OUT] Array{Cint, 1}</li>
<li>lhe_row:    [IN] Array{Cint, 1}</li>
<li>he_row:     [OUT] Array{Cint, 1}</li>
<li>lhe_val:    [IN] Array{Cint, 1}</li>
<li>he_val:     [OUT] Array{Cdouble, 1}</li>
<li>byrows:     [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ufn-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ufn-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ufn</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ufn</strong></p>
<p>The ufn subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ufn
</code></pre>

<p>Usage:</p>
<pre><code>ufn(io_err, n, x, f)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.ugr-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ugr-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugr</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ugr</strong></p>
<p>The ugr subroutine evaluates the gradient of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ugr
</code></pre>

<p>Usage:</p>
<pre><code>ugr(io_err, n, x, g)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.ugrdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}' href='#CUTEst.ugrdh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Float64,2}}'>#</a>
<strong><code>CUTEst.ugrdh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ugrdh</strong></p>
<p>The ugrdh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a dense matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ugrdh
</code></pre>

<p>Usage:</p>
<pre><code>ugrdh(io_err, n, x, g, lh1, h)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>lh1:     [IN] Array{Cint, 1}</li>
<li>h:       [OUT] Array{Cdouble, 2}</li>
</ul>
<p><a id='CUTEst.ugreh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.ugreh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ugreh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ugreh</strong></p>
<p>The ugreh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in finite element format H=eΣ1He, where each square symmetric element H sub e involves a small subset of the rows of the Hessian matrix. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ugreh
</code></pre>

<p>Usage:</p>
<pre><code>ugreh(io_err, n, x, g, ne, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row,
</code></pre>

<p>lhe_val, he_val, byrows)</p>
<ul>
<li>io_err:     [OUT] Array{Cint, 1}</li>
<li>n:          [IN] Array{Cint, 1}</li>
<li>x:          [IN] Array{Cdouble, 1}</li>
<li>g:          [OUT] Array{Cdouble, 1}</li>
<li>ne:         [OUT] Array{Cint, 1}</li>
<li>lhe_ptr:    [IN] Array{Cint, 1}</li>
<li>he_row_ptr: [OUT] Array{Cint, 1}</li>
<li>he_val_ptr: [OUT] Array{Cint, 1}</li>
<li>lhe_row:    [IN] Array{Cint, 1}</li>
<li>he_row:     [OUT] Array{Cint, 1}</li>
<li>lhe_val:    [IN] Array{Cint, 1}</li>
<li>he_val:     [OUT] Array{Cdouble, 1}</li>
<li>byrows:     [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ugrsh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ugrsh-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ugrsh</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ugrsh</strong></p>
<p>The ugrsh subroutine evaluates the gradient and Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ugrsh
</code></pre>

<p>Usage:</p>
<pre><code>ugrsh(io_err, n, x, g, nnzh, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.uhprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.uhprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.uhprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>uhprod</strong></p>
<p>The uhprod subroutine forms the product of a vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_uhprod
</code></pre>

<p>Usage:</p>
<pre><code>uhprod(io_err, n, goth, x, vector, result)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>goth:    [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>vector:  [IN] Array{Cdouble, 1}</li>
<li>result:  [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.unames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1},Array{Int8,1}}' href='#CUTEst.unames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.unames</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>unames</strong></p>
<p>The unames subroutine obtains the names of the problem and its variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_unames
</code></pre>

<p>Usage:</p>
<pre><code>unames(io_err, n, pname, vname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>pname:   [OUT] Array{Cchar, 1}</li>
<li>vname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.uofg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}' href='#CUTEst.uofg-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.uofg</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>uofg</strong></p>
<p>The uofg subroutine evaluates the value of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X, and possibly its gradient. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_uofg
</code></pre>

<p>Usage:</p>
<pre><code>uofg(io_err, n, x, f, g, grad)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>f:       [OUT] Array{Cdouble, 1}</li>
<li>g:       [OUT] Array{Cdouble, 1}</li>
<li>grad:    [IN] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ureport-Tuple{Array{Int32,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ureport-Tuple{Array{Int32,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ureport</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ureport</strong></p>
<p>The ureport subroutine obtains statistics concerning function evaluation and CPU time used for unconstrained or bound-constrained optimization in a standardized format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ureport
</code></pre>

<p>Usage:</p>
<pre><code>ureport(io_err, calls, time)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>calls:   [OUT] Array{Cdouble, 1}</li>
<li>time:    [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.usetup-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.usetup-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.usetup</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>usetup</strong></p>
<p>The usetup subroutine sets up the correct data structures for subsequent computations in the case where the only possible constraints are bound constraints. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_usetup
</code></pre>

<p>Usage:</p>
<pre><code>usetup(io_err, input, out, io_buffer, n, x, x_l, x_u)
</code></pre>

<ul>
<li>io_err:    [OUT] Array{Cint, 1}</li>
<li>input:     [IN] Array{Cint, 1}</li>
<li>out:       [IN] Array{Cint, 1}</li>
<li>io_buffer: [IN] Array{Cint, 1}</li>
<li>n:         [IN] Array{Cint, 1}</li>
<li>x:         [OUT] Array{Cdouble, 1}</li>
<li>x_l:       [OUT] Array{Cdouble, 1}</li>
<li>x_u:       [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.ush-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ush-Tuple{Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ush</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ush</strong></p>
<p>The ush subroutine evaluates the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. This Hessian matrix is stored as a sparse matrix in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group- partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ush
</code></pre>

<p>Usage:</p>
<pre><code>ush(io_err, n, x, nnzh, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x:       [IN] Array{Cdouble, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_val:   [OUT] Array{Cdouble, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ushp-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.ushp-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.ushp</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ushp</strong></p>
<p>The ushp subroutine evaluates the sparsity pattern of the Hessian matrix of the objective function of the problem, decoded from a SIF file by the script sifdecoder, in coordinate format. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ushp
</code></pre>

<p>Usage:</p>
<pre><code>ushp(io_err, n, nnzh, lh, h_row, h_col)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>nnzh:    [OUT] Array{Cint, 1}</li>
<li>lh:      [IN] Array{Cint, 1}</li>
<li>h_row:   [OUT] Array{Cint, 1}</li>
<li>h_col:   [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.ushprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}' href='#CUTEst.ushprod-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1},Array{Int32,1},Array{Int32,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ushprod</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>ushprod</strong></p>
<p>The ushprod subroutine forms the product of a sparse vector with the Hessian matrix of the objective function of the problem decoded from a SIF file by the script sifdecoder at the point X. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_ushprod
</code></pre>

<p>Usage:</p>
<pre><code>ushprod(io_err, n, goth, x, nnz_vector, index_nz_vector, vector, nnz_result,
</code></pre>

<p>index_nz_result, result)</p>
<ul>
<li>io_err:          [OUT] Array{Cint, 1}</li>
<li>n:               [IN] Array{Cint, 1}</li>
<li>goth:            [IN] Array{Cint, 1}</li>
<li>x:               [IN] Array{Cdouble, 1}</li>
<li>nnz_vector:      [IN] Array{Cint, 1}</li>
<li>index_nz_vector: [IN] Array{Cint, 1}</li>
<li>vector:          [IN] Array{Cdouble, 1}</li>
<li>nnz_result:      [OUT] Array{Cint, 1}</li>
<li>index_nz_result: [OUT] Array{Cint, 1}</li>
<li>result:          [OUT] Array{Cdouble, 1}</li>
</ul>
<p><a id='CUTEst.uterminate-Tuple{Array{Int32,1}}' href='#CUTEst.uterminate-Tuple{Array{Int32,1}}'>#</a>
<strong><code>CUTEst.uterminate</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>uterminate</strong></p>
<p>The uterminate subroutine deallocates all workspace arrays created since the last call to usetup.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_uterminate
</code></pre>

<p>Usage:</p>
<pre><code>uterminate(io_err)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.uvartype-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}' href='#CUTEst.uvartype-Tuple{Array{Int32,1},Array{Int32,1},Array{Int32,1}}'>#</a>
<strong><code>CUTEst.uvartype</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>uvartype</strong></p>
<p>The uvartype subroutine determines the type (continuous, 0-1, integer) of each variable involved in the problem decoded from a SIF file by the script sifdecoder. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to the simple bounds xl≤x≤xu. The objective function is group-partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_uvartype
</code></pre>

<p>Usage:</p>
<pre><code>uvartype(io_err, n, x_type)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>x_type:  [OUT] Array{Cint, 1}</li>
</ul>
<p><a id='CUTEst.varnames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}' href='#CUTEst.varnames-Tuple{Array{Int32,1},Array{Int32,1},Array{Int8,1}}'>#</a>
<strong><code>CUTEst.varnames</code></strong> &mdash; <em>Method</em>.</p>
<p><strong>varnames</strong></p>
<p>The varnames subroutine obtains the names of the problem variables. The problem under consideration is to minimize or maximize an objective function f(x) over all x ∈ Rn subject to general equations ci(x)=0, (i ∈ 1,...,mE), general inequalities ci(x)≤ci(x)≤ci(x), (i ∈ mE+1,...,m), and simple bounds xl≤x≤xu. The objective function is group-partially separable and all constraint functions are partially separable.</p>
<p>For more information, run the shell command</p>
<pre><code>man cutest_varnames
</code></pre>

<p>Usage:</p>
<pre><code>varnames(io_err, n, vname)
</code></pre>

<ul>
<li>io_err:  [OUT] Array{Cint, 1}</li>
<li>n:       [IN] Array{Cint, 1}</li>
<li>vname:   [OUT] Array{Cchar, 1}</li>
</ul>
<p><a id='CUTEst.ccfg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Bool}' href='#CUTEst.ccfg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Bool}'>#</a>
<strong><code>CUTEst.ccfg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ccfg!(nlp, x, c, jtrans, lcjac1, lcjac2, cjac, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lcjac1:  [IN] Int</li>
<li>lcjac2:  [IN] Int</li>
<li>cjac:    [OUT] Array{Float64, 2}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Bool}' href='#CUTEst.ccfg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Bool}'>#</a>
<strong><code>CUTEst.ccfg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ccfg!(n, m, x, c, jtrans, lcjac1, lcjac2, cjac, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lcjac1:  [IN] Int</li>
<li>lcjac2:  [IN] Int</li>
<li>cjac:    [OUT] Array{Float64, 2}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool,Int64,Int64,Bool}' href='#CUTEst.ccfg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ccfg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>c, cjac = ccfg(nlp, x, jtrans, lcjac1, lcjac2, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lcjac1:  [IN] Int</li>
<li>lcjac2:  [IN] Int</li>
<li>cjac:    [OUT] Array{Float64, 2}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfg-Tuple{Int64,Int64,Array{Float64,1},Bool,Int64,Int64,Bool}' href='#CUTEst.ccfg-Tuple{Int64,Int64,Array{Float64,1},Bool,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ccfg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>c, cjac = ccfg(n, m, x, jtrans, lcjac1, lcjac2, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lcjac1:  [IN] Int</li>
<li>lcjac2:  [IN] Int</li>
<li>cjac:    [OUT] Array{Float64, 2}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfsg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1},Bool}' href='#CUTEst.ccfsg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.ccfsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj = ccfsg!(nlp, x, c, j_val, j_var, j_fun, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfsg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Bool}' href='#CUTEst.ccfsg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.ccfsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj = ccfsg!(n, m, x, c, lj, j_val, j_var, j_fun, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfsg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}' href='#CUTEst.ccfsg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ccfsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>c, nnzj, j_val, j_var, j_fun = ccfsg(nlp, x, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccfsg-Tuple{Int64,Int64,Array{Float64,1},Int64,Bool}' href='#CUTEst.ccfsg-Tuple{Int64,Int64,Array{Float64,1},Int64,Bool}'>#</a>
<strong><code>CUTEst.ccfsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>c, nnzj, j_val, j_var, j_fun = ccfsg(n, m, x, lj, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>c:       [OUT] Array{Float64, 1}</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cchprods!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cchprods!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cchprods!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cchprods!(nlp, goth, x, vector, lchp, chp_val, chp_ind, chp_ptr)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lchp:    [IN] Int</li>
<li>chp_val: [OUT] Array{Float64, 1}</li>
<li>chp_ind: [IN] Array{Int, 1}</li>
<li>chp_ptr: [IN] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cchprods!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cchprods!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cchprods!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cchprods!(n, m, goth, x, vector, lchp, chp_val, chp_ind, chp_ptr)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lchp:    [IN] Int</li>
<li>chp_val: [OUT] Array{Float64, 1}</li>
<li>chp_ind: [IN] Array{Int, 1}</li>
<li>chp_ptr: [IN] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cchprods-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cchprods-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cchprods</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chp_val = cchprods(nlp, goth, x, vector, lchp, chp_ind, chp_ptr)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lchp:    [IN] Int</li>
<li>chp_val: [OUT] Array{Float64, 1}</li>
<li>chp_ind: [IN] Array{Int, 1}</li>
<li>chp_ptr: [IN] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cchprods-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cchprods-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cchprods</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chp_val = cchprods(n, m, goth, x, vector, lchp, chp_ind, chp_ptr)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lchp:    [IN] Int</li>
<li>chp_val: [OUT] Array{Float64, 1}</li>
<li>chp_ind: [IN] Array{Int, 1}</li>
<li>chp_ptr: [IN] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ccifg!-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.ccifg!-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci = ccifg!(nlp, icon, x, gci, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>gci:     [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.ccifg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci = ccifg!(n, icon, x, gci, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>gci:     [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifg-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Bool}' href='#CUTEst.ccifg-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, gci = ccifg(nlp, icon, x, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>gci:     [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifg-Tuple{Int64,Int64,Array{Float64,1},Bool}' href='#CUTEst.ccifg-Tuple{Int64,Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, gci = ccifg(n, icon, x, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>gci:     [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifsg!-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}' href='#CUTEst.ccifsg!-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, nnzgci = ccifsg!(nlp, icon, x, lgci, gci_val, gci_var, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>nnzgci:  [OUT] Int</li>
<li>lgci:    [IN] Int</li>
<li>gci_val: [OUT] Array{Float64, 1}</li>
<li>gci_var: [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifsg!-Tuple{Int64,Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}' href='#CUTEst.ccifsg!-Tuple{Int64,Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.ccifsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, nnzgci = ccifsg!(n, icon, x, lgci, gci_val, gci_var, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>nnzgci:  [OUT] Int</li>
<li>lgci:    [IN] Int</li>
<li>gci_val: [OUT] Array{Float64, 1}</li>
<li>gci_var: [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifsg-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Int64,Bool}' href='#CUTEst.ccifsg-Tuple{CUTEst.CUTEstModel,Int64,Array{Float64,1},Int64,Bool}'>#</a>
<strong><code>CUTEst.ccifsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, nnzgci, gci_val, gci_var = ccifsg(nlp, icon, x, lgci, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>nnzgci:  [OUT] Int</li>
<li>lgci:    [IN] Int</li>
<li>gci_val: [OUT] Array{Float64, 1}</li>
<li>gci_var: [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ccifsg-Tuple{Int64,Int64,Array{Float64,1},Int64,Bool}' href='#CUTEst.ccifsg-Tuple{Int64,Int64,Array{Float64,1},Int64,Bool}'>#</a>
<strong><code>CUTEst.ccifsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ci, nnzgci, gci_val, gci_var = ccifsg(n, icon, x, lgci, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>icon:    [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>ci:      [OUT] Float64</li>
<li>nnzgci:  [OUT] Int</li>
<li>lgci:    [IN] Int</li>
<li>gci_val: [OUT] Array{Float64, 1}</li>
<li>gci_var: [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.cdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cdh!(nlp, x, y, lh1, h_val)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.cdh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cdh!(n, m, x, y, lh1, h_val)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.cdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_val = cdh(nlp, x, y, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.cdh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_val = cdh(n, m, x, y, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdhc!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.cdhc!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdhc!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cdhc!(nlp, x, y, lh1, h_val)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdhc!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.cdhc!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cdhc!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cdhc!(n, m, x, y, lh1, h_val)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdhc-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.cdhc-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cdhc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_val = cdhc(nlp, x, y, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdhc-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.cdhc-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cdhc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_val = cdhc(n, m, x, y, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cdimchp-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.cdimchp-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.cdimchp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzchp = cdimchp(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>nnzchp:  [OUT] Int</li>
</ul>
<p><a id='CUTEst.cdimchp-Tuple{}' href='#CUTEst.cdimchp-Tuple{}'>#</a>
<strong><code>CUTEst.cdimchp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzchp = cdimchp()
</code></pre>

<ul>
<li>nnzchp:  [OUT] Int</li>
</ul>
<p><a id='CUTEst.cdimen-Tuple{Int64}' href='#CUTEst.cdimen-Tuple{Int64}'>#</a>
<strong><code>CUTEst.cdimen</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>n, m = cdimen(input)
</code></pre>

<ul>
<li>input:   [IN] Int</li>
<li>n:       [OUT] Int</li>
<li>m:       [OUT] Int</li>
</ul>
<p><a id='CUTEst.cdimse-Tuple{}' href='#CUTEst.cdimse-Tuple{}'>#</a>
<strong><code>CUTEst.cdimse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_val_ne, he_row_ne = cdimse()
</code></pre>

<ul>
<li>ne:        [OUT] Int</li>
<li>he_val_ne: [OUT] Int</li>
<li>he_row_ne: [OUT] Int</li>
</ul>
<p><a id='CUTEst.cdimsh-Tuple{}' href='#CUTEst.cdimsh-Tuple{}'>#</a>
<strong><code>CUTEst.cdimsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cdimsh()
</code></pre>

<ul>
<li>nnzh:    [OUT] Int</li>
</ul>
<p><a id='CUTEst.cdimsj-Tuple{}' href='#CUTEst.cdimsj-Tuple{}'>#</a>
<strong><code>CUTEst.cdimsj</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj = cdimsj()
</code></pre>

<ul>
<li>nnzj:    [OUT] Int</li>
</ul>
<p><a id='CUTEst.ceh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ceh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ceh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ceh!(nlp, x, y, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ceh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ceh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ceh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ceh!(n, m, x, y, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>m:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ceh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ceh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ceh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_row_ptr, he_val_ptr, he_row, he_val = ceh(nlp, x, y, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ceh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ceh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ceh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_row_ptr, he_val_ptr, he_row, he_val = ceh(n, m, x, y, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>m:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.cfn!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.cfn!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cfn!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = cfn!(nlp, x, c)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>c:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cfn!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.cfn!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cfn!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = cfn!(n, m, x, c)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>c:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cfn-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}' href='#CUTEst.cfn-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cfn</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, c = cfn(nlp, x)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>c:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cfn-Tuple{Int64,Int64,Array{Float64,1}}' href='#CUTEst.cfn-Tuple{Int64,Int64,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cfn</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, c = cfn(n, m, x)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>c:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cgr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2}}' href='#CUTEst.cgr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cgr!(nlp, x, y, grlagf, g, jtrans, lj1, lj2, j_val)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgr!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2}}' href='#CUTEst.cgr!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cgr!(n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgr-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64}' href='#CUTEst.cgr-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64}'>#</a>
<strong><code>CUTEst.cgr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, j_val = cgr(nlp, x, y, grlagf, jtrans, lj1, lj2)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgr-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64}' href='#CUTEst.cgr-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64}'>#</a>
<strong><code>CUTEst.cgr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, j_val = cgr(n, m, x, y, grlagf, jtrans, lj1, lj2)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgrdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Int64,Array{Float64,2}}' href='#CUTEst.cgrdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgrdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cgrdh!(nlp, x, y, grlagf, g, jtrans, lj1, lj2, j_val, lh1, h_val)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgrdh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Int64,Array{Float64,2}}' href='#CUTEst.cgrdh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Bool,Int64,Int64,Array{Float64,2},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cgrdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cgrdh!(n, m, x, y, grlagf, g, jtrans, lj1, lj2, j_val, lh1, h_val)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgrdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64,Int64}' href='#CUTEst.cgrdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64,Int64}'>#</a>
<strong><code>CUTEst.cgrdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, j_val, h_val = cgrdh(nlp, x, y, grlagf, jtrans, lj1, lj2, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cgrdh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64,Int64}' href='#CUTEst.cgrdh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Bool,Int64,Int64,Int64}'>#</a>
<strong><code>CUTEst.cgrdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, j_val, h_val = cgrdh(n, m, x, y, grlagf, jtrans, lj1, lj2, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>jtrans:  [IN] Bool</li>
<li>lj1:     [IN] Int</li>
<li>lj2:     [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 2}</li>
<li>lh1:     [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.chcprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chcprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chcprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chcprod!(nlp, goth, x, y, vector, result)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chcprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chcprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chcprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chcprod!(n, m, goth, x, y, vector, result)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chcprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chcprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chcprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = chcprod(nlp, goth, x, y, vector)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chcprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chcprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chcprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = chcprod(n, m, goth, x, y, vector)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chprod!(nlp, goth, x, y, vector, result)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>chprod!(n, m, goth, x, y, vector, result)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = chprod(nlp, goth, x, y, vector)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.chprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.chprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.chprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = chprod(n, m, goth, x, y, vector)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cidh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Array{Float64,2}}' href='#CUTEst.cidh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cidh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cidh!(nlp, x, iprob, lh1, h)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cidh!-Tuple{Int64,Array{Float64,1},Int64,Int64,Array{Float64,2}}' href='#CUTEst.cidh!-Tuple{Int64,Array{Float64,1},Int64,Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.cidh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cidh!(n, x, iprob, lh1, h)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cidh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64}' href='#CUTEst.cidh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.cidh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h = cidh(nlp, x, iprob, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cidh-Tuple{Int64,Array{Float64,1},Int64,Int64}' href='#CUTEst.cidh-Tuple{Int64,Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.cidh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h = cidh(n, x, iprob, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.cish!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cish!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cish!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cish!(nlp, x, iprob, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cish!-Tuple{Int64,Array{Float64,1},Int64,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cish!-Tuple{Int64,Array{Float64,1},Int64,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cish!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cish!(n, x, iprob, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cish-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}' href='#CUTEst.cish-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cish</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = cish(nlp, x, iprob)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cish-Tuple{Int64,Array{Float64,1},Int64,Int64}' href='#CUTEst.cish-Tuple{Int64,Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.cish</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = cish(n, x, iprob, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>iprob:   [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cjprod!-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Int64}' href='#CUTEst.cjprod!-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cjprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cjprod!(nlp, gotj, jtrans, x, vector, lvector, result, lresult)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>gotj:    [IN] Bool</li>
<li>jtrans:  [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lvector: [IN] Int</li>
<li>result:  [OUT] Array{Float64, 1}</li>
<li>lresult: [IN] Int</li>
</ul>
<p><a id='CUTEst.cjprod!-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Int64}' href='#CUTEst.cjprod!-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cjprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cjprod!(n, m, gotj, jtrans, x, vector, lvector, result, lresult)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>gotj:    [IN] Bool</li>
<li>jtrans:  [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lvector: [IN] Int</li>
<li>result:  [OUT] Array{Float64, 1}</li>
<li>lresult: [IN] Int</li>
</ul>
<p><a id='CUTEst.cjprod-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Int64}' href='#CUTEst.cjprod-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.cjprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = cjprod(nlp, gotj, jtrans, x, vector, lvector, lresult)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>gotj:    [IN] Bool</li>
<li>jtrans:  [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lvector: [IN] Int</li>
<li>result:  [OUT] Array{Float64, 1}</li>
<li>lresult: [IN] Int</li>
</ul>
<p><a id='CUTEst.cjprod-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Int64}' href='#CUTEst.cjprod-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.cjprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = cjprod(n, m, gotj, jtrans, x, vector, lvector, lresult)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>gotj:    [IN] Bool</li>
<li>jtrans:  [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>lvector: [IN] Int</li>
<li>result:  [OUT] Array{Float64, 1}</li>
<li>lresult: [IN] Int</li>
</ul>
<p><a id='CUTEst.clfg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.clfg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.clfg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = clfg!(nlp, x, y, g, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.clfg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.clfg!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.clfg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = clfg!(n, m, x, y, g, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.clfg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.clfg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.clfg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = clfg(nlp, x, y, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.clfg-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.clfg-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.clfg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = clfg(n, m, x, y, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cnames!-Tuple{CUTEst.CUTEstModel,Array{UInt8,1},Array{UInt8,1}}' href='#CUTEst.cnames!-Tuple{CUTEst.CUTEstModel,Array{UInt8,1},Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.cnames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = cnames!(nlp, vname, cname)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.cnames!-Tuple{Int64,Int64,Array{UInt8,1},Array{UInt8,1}}' href='#CUTEst.cnames!-Tuple{Int64,Int64,Array{UInt8,1},Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.cnames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = cnames!(n, m, vname, cname)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.cnames-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.cnames-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.cnames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname, vname, cname = cnames(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.cnames-Tuple{Int64,Int64}' href='#CUTEst.cnames-Tuple{Int64,Int64}'>#</a>
<strong><code>CUTEst.cnames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname, vname, cname = cnames(n, m)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.cofg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.cofg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.cofg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = cofg!(nlp, x, g, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofg!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.cofg!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.cofg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = cofg!(n, x, g, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}' href='#CUTEst.cofg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.cofg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = cofg(nlp, x, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofg-Tuple{Int64,Array{Float64,1},Bool}' href='#CUTEst.cofg-Tuple{Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.cofg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = cofg(n, x, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofsg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}' href='#CUTEst.cofsg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.cofsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, nnzg = cofsg!(nlp, x, lg, g_val, g_var, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>nnzg:    [OUT] Int</li>
<li>lg:      [IN] Int</li>
<li>g_val:   [OUT] Array{Float64, 1}</li>
<li>g_var:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofsg!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}' href='#CUTEst.cofsg!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Bool}'>#</a>
<strong><code>CUTEst.cofsg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, nnzg = cofsg!(n, x, lg, g_val, g_var, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>nnzg:    [OUT] Int</li>
<li>lg:      [IN] Int</li>
<li>g_val:   [OUT] Array{Float64, 1}</li>
<li>g_var:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofsg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Bool}' href='#CUTEst.cofsg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Bool}'>#</a>
<strong><code>CUTEst.cofsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, nnzg, g_val, g_var = cofsg(nlp, x, lg, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>nnzg:    [OUT] Int</li>
<li>lg:      [IN] Int</li>
<li>g_val:   [OUT] Array{Float64, 1}</li>
<li>g_var:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.cofsg-Tuple{Int64,Array{Float64,1},Int64,Bool}' href='#CUTEst.cofsg-Tuple{Int64,Array{Float64,1},Int64,Bool}'>#</a>
<strong><code>CUTEst.cofsg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, nnzg, g_val, g_var = cofsg(n, x, lg, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>nnzg:    [OUT] Int</li>
<li>lg:      [IN] Int</li>
<li>g_val:   [OUT] Array{Float64, 1}</li>
<li>g_var:   [OUT] Array{Int, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.connames!-Tuple{CUTEst.CUTEstModel,Array{UInt8,1}}' href='#CUTEst.connames!-Tuple{CUTEst.CUTEstModel,Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.connames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>connames!(nlp, cname)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.connames!-Tuple{Int64,Array{UInt8,1}}' href='#CUTEst.connames!-Tuple{Int64,Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.connames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>connames!(m, cname)
</code></pre>

<ul>
<li>m:       [IN] Int</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.connames-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.connames-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.connames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cname = connames(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.connames-Tuple{Int64}' href='#CUTEst.connames-Tuple{Int64}'>#</a>
<strong><code>CUTEst.connames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cname = connames(m)
</code></pre>

<ul>
<li>m:       [IN] Int</li>
<li>cname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.creport!-Tuple{Array{Float64,1},Array{Float64,1}}' href='#CUTEst.creport!-Tuple{Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.creport!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>creport!(calls, time)
</code></pre>

<ul>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.creport!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.creport!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.creport!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>creport!(nlp, calls, time)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.creport-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.creport-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.creport</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>calls, time = creport(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.creport-Tuple{}' href='#CUTEst.creport-Tuple{}'>#</a>
<strong><code>CUTEst.creport</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>calls, time = creport()
</code></pre>

<ul>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.csetup!-Tuple{Int64,Int64,Int64,Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Bool,1},Array{Bool,1},Int64,Int64,Int64}' href='#CUTEst.csetup!-Tuple{Int64,Int64,Int64,Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Bool,1},Array{Bool,1},Int64,Int64,Int64}'>#</a>
<strong><code>CUTEst.csetup!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>csetup!(input, out, io_buffer, n, m, x, x_l, x_u, y, c_l, c_u, equatn, linear, e_order, l_order, v_order)
</code></pre>

<ul>
<li>input:     [IN] Int</li>
<li>out:       [IN] Int</li>
<li>io_buffer: [IN] Int</li>
<li>n:         [IN] Int</li>
<li>m:         [IN] Int</li>
<li>x:         [OUT] Array{Float64, 1}</li>
<li>x_l:       [OUT] Array{Float64, 1}</li>
<li>x_u:       [OUT] Array{Float64, 1}</li>
<li>y:         [OUT] Array{Float64, 1}</li>
<li>c_l:       [OUT] Array{Float64, 1}</li>
<li>c_u:       [OUT] Array{Float64, 1}</li>
<li>equatn:    [OUT] Array{Bool, 1}</li>
<li>linear:    [OUT] Array{Bool, 1}</li>
<li>e_order:   [IN] Int</li>
<li>l_order:   [IN] Int</li>
<li>v_order:   [IN] Int</li>
</ul>
<p><a id='CUTEst.csetup-Tuple{Int64,Int64,Int64,Int64,Int64,Int64,Int64,Int64}' href='#CUTEst.csetup-Tuple{Int64,Int64,Int64,Int64,Int64,Int64,Int64,Int64}'>#</a>
<strong><code>CUTEst.csetup</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>x, x_l, x_u, y, c_l, c_u, equatn, linear = csetup(input, out, io_buffer, n, m, e_order, l_order, v_order)
</code></pre>

<ul>
<li>input:     [IN] Int</li>
<li>out:       [IN] Int</li>
<li>io_buffer: [IN] Int</li>
<li>n:         [IN] Int</li>
<li>m:         [IN] Int</li>
<li>x:         [OUT] Array{Float64, 1}</li>
<li>x_l:       [OUT] Array{Float64, 1}</li>
<li>x_u:       [OUT] Array{Float64, 1}</li>
<li>y:         [OUT] Array{Float64, 1}</li>
<li>c_l:       [OUT] Array{Float64, 1}</li>
<li>c_u:       [OUT] Array{Float64, 1}</li>
<li>equatn:    [OUT] Array{Bool, 1}</li>
<li>linear:    [OUT] Array{Bool, 1}</li>
<li>e_order:   [IN] Int</li>
<li>l_order:   [IN] Int</li>
<li>v_order:   [IN] Int</li>
</ul>
<p><a id='CUTEst.csgr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csgr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csgr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj = csgr!(nlp, x, y, grlagf, j_val, j_var, j_fun)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgr!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csgr!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csgr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj = csgr!(n, m, x, y, grlagf, lj, j_val, j_var, j_fun)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgr-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.csgr-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.csgr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun = csgr(nlp, x, y, grlagf)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgr-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64}' href='#CUTEst.csgr-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64}'>#</a>
<strong><code>CUTEst.csgr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun = csgr(n, m, x, y, grlagf, lj)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgreh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.csgreh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.csgreh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, ne = csgreh!(nlp, x, y, grlagf, j_val, j_var, j_fun, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>grlagf:     [IN] Bool</li>
<li>nnzj:       [OUT] Int</li>
<li>j_val:      [OUT] Array{Float64, 1}</li>
<li>j_var:      [OUT] Array{Int, 1}</li>
<li>j_fun:      [OUT] Array{Int, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.csgreh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.csgreh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.csgreh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, ne = csgreh!(n, m, x, y, grlagf, lj, j_val, j_var, j_fun, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>m:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>grlagf:     [IN] Bool</li>
<li>nnzj:       [OUT] Int</li>
<li>lj:         [IN] Int</li>
<li>j_val:      [OUT] Array{Float64, 1}</li>
<li>j_var:      [OUT] Array{Int, 1}</li>
<li>j_fun:      [OUT] Array{Int, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.csgreh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Int64,Bool}' href='#CUTEst.csgreh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.csgreh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun, ne, he_row_ptr, he_val_ptr, he_row, he_val = csgreh(nlp, x, y, grlagf, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>grlagf:     [IN] Bool</li>
<li>nnzj:       [OUT] Int</li>
<li>j_val:      [OUT] Array{Float64, 1}</li>
<li>j_var:      [OUT] Array{Int, 1}</li>
<li>j_fun:      [OUT] Array{Int, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.csgreh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Int64,Int64,Bool}' href='#CUTEst.csgreh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.csgreh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun, ne, he_row_ptr, he_val_ptr, he_row, he_val = csgreh(n, m, x, y, grlagf, lj, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>m:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>y:          [IN] Array{Float64, 1}</li>
<li>grlagf:     [IN] Bool</li>
<li>nnzj:       [OUT] Int</li>
<li>lj:         [IN] Int</li>
<li>j_val:      [OUT] Array{Float64, 1}</li>
<li>j_var:      [OUT] Array{Int, 1}</li>
<li>j_fun:      [OUT] Array{Int, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.csgrsh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csgrsh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool,Array{Float64,1},Array{Int64,1},Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csgrsh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, nnzh = csgrsh!(nlp, x, y, grlagf, j_val, j_var, j_fun, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgrsh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csgrsh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csgrsh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, nnzh = csgrsh!(n, m, x, y, grlagf, lj, j_val, j_var, j_fun, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgrsh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.csgrsh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.csgrsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun, nnzh, h_val, h_row, h_col = csgrsh(nlp, x, y, grlagf)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csgrsh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64}' href='#CUTEst.csgrsh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Bool,Int64,Int64}'>#</a>
<strong><code>CUTEst.csgrsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzj, j_val, j_var, j_fun, nnzh, h_val, h_row, h_col = csgrsh(n, m, x, y, grlagf, lj, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>grlagf:  [IN] Bool</li>
<li>nnzj:    [OUT] Int</li>
<li>lj:      [IN] Int</li>
<li>j_val:   [OUT] Array{Float64, 1}</li>
<li>j_var:   [OUT] Array{Int, 1}</li>
<li>j_fun:   [OUT] Array{Int, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = csh!(nlp, x, y, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.csh!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.csh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = csh!(n, m, x, y, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.csh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.csh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = csh(nlp, x, y)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.csh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.csh-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.csh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = csh(n, m, x, y, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshc!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cshc!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cshc!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cshc!(nlp, x, y, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshc!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cshc!-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cshc!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cshc!(n, m, x, y, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshc-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.cshc-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = cshc(nlp, x, y)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshc-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}' href='#CUTEst.cshc-Tuple{Int64,Int64,Array{Float64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.cshc</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = cshc(n, m, x, y, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>m:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>y:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshcprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshcprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshcprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = cshcprod!(nlp, goth, x, y, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshcprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshcprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshcprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = cshcprod!(n, m, goth, x, y, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshcprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshcprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshcprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = cshcprod(nlp, goth, x, y, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshcprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshcprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshcprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = cshcprod(n, m, goth, x, y, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshp!-Tuple{CUTEst.CUTEstModel,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cshp!-Tuple{CUTEst.CUTEstModel,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cshp!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cshp!(nlp, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>nnzh:    [OUT] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshp!-Tuple{Int64,Int64,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.cshp!-Tuple{Int64,Int64,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cshp!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = cshp!(n, lh, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshp-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.cshp-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.cshp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_row, h_col = cshp(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>nnzh:    [OUT] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshp-Tuple{Int64,Int64}' href='#CUTEst.cshp-Tuple{Int64,Int64}'>#</a>
<strong><code>CUTEst.cshp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_row, h_col = cshp(n, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cshprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = cshprod!(nlp, goth, x, y, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshprod!-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = cshprod!(n, m, goth, x, y, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = cshprod(nlp, goth, x, y, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.cshprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.cshprod-Tuple{Int64,Int64,Bool,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.cshprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = cshprod(n, m, goth, x, y, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>y:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.csjprod!-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64}' href='#CUTEst.csjprod!-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.csjprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = csjprod!(nlp, gotj, jtrans, x, nnz_vector, index_nz_vector, vector, lvector, index_nz_result, result, lresult)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>gotj:            [IN] Bool</li>
<li>jtrans:          [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>lvector:         [IN] Int</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
<li>lresult:         [IN] Int</li>
</ul>
<p><a id='CUTEst.csjprod!-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64}' href='#CUTEst.csjprod!-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.csjprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = csjprod!(n, m, gotj, jtrans, x, nnz_vector, index_nz_vector, vector, lvector, index_nz_result, result, lresult)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>gotj:            [IN] Bool</li>
<li>jtrans:          [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>lvector:         [IN] Int</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
<li>lresult:         [IN] Int</li>
</ul>
<p><a id='CUTEst.csjprod-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Int64}' href='#CUTEst.csjprod-Tuple{CUTEst.CUTEstModel,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.csjprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = csjprod(nlp, gotj, jtrans, x, nnz_vector, index_nz_vector, vector, lvector, lresult)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>gotj:            [IN] Bool</li>
<li>jtrans:          [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>lvector:         [IN] Int</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
<li>lresult:         [IN] Int</li>
</ul>
<p><a id='CUTEst.csjprod-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Int64}' href='#CUTEst.csjprod-Tuple{Int64,Int64,Bool,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.csjprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = csjprod(n, m, gotj, jtrans, x, nnz_vector, index_nz_vector, vector, lvector, lresult)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>m:               [IN] Int</li>
<li>gotj:            [IN] Bool</li>
<li>jtrans:          [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>lvector:         [IN] Int</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
<li>lresult:         [IN] Int</li>
</ul>
<p><a id='CUTEst.cstats-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.cstats-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.cstats</code></strong> &mdash; <em>Method</em>.</p>
<p><a id='CUTEst.cstats-Tuple{}' href='#CUTEst.cstats-Tuple{}'>#</a>
<strong><code>CUTEst.cstats</code></strong> &mdash; <em>Method</em>.</p>
<p><a id='CUTEst.cterminate-Tuple{}' href='#CUTEst.cterminate-Tuple{}'>#</a>
<strong><code>CUTEst.cterminate</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cterminate()
</code></pre>

<p><a id='CUTEst.cvartype!-Tuple{Int64,Array{Int64,1}}' href='#CUTEst.cvartype!-Tuple{Int64,Array{Int64,1}}'>#</a>
<strong><code>CUTEst.cvartype!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>cvartype!(n, x_type)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x_type:  [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.cvartype-Tuple{Int64}' href='#CUTEst.cvartype-Tuple{Int64}'>#</a>
<strong><code>CUTEst.cvartype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>x_type = cvartype(n)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x_type:  [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.pname-Tuple{CUTEst.CUTEstModel,Int64}' href='#CUTEst.pname-Tuple{CUTEst.CUTEstModel,Int64}'>#</a>
<strong><code>CUTEst.pname</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = pname(nlp, input)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>input:   [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
</ul>
<p><a id='CUTEst.pname-Tuple{Int64}' href='#CUTEst.pname-Tuple{Int64}'>#</a>
<strong><code>CUTEst.pname</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = pname(input)
</code></pre>

<ul>
<li>input:   [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
</ul>
<p><a id='CUTEst.probname-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.probname-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.probname</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = probname(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>pname:   [OUT] UInt8</li>
</ul>
<p><a id='CUTEst.probname-Tuple{}' href='#CUTEst.probname-Tuple{}'>#</a>
<strong><code>CUTEst.probname</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = probname()
</code></pre>

<ul>
<li>pname:   [OUT] UInt8</li>
</ul>
<p><a id='CUTEst.ubandh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,2},Int64}' href='#CUTEst.ubandh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,2},Int64}'>#</a>
<strong><code>CUTEst.ubandh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>max_semibandwidth = ubandh!(nlp, x, semibandwidth, h_band, lbandh)
</code></pre>

<ul>
<li>nlp:               [IN] CUTEstModel</li>
<li>x:                 [IN] Array{Float64, 1}</li>
<li>semibandwidth:     [IN] Int</li>
<li>h_band:            [OUT] Array{Float64, 2}</li>
<li>lbandh:            [IN] Int</li>
<li>max_semibandwidth: [OUT] Int</li>
</ul>
<p><a id='CUTEst.ubandh!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,2},Int64}' href='#CUTEst.ubandh!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,2},Int64}'>#</a>
<strong><code>CUTEst.ubandh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>max_semibandwidth = ubandh!(n, x, semibandwidth, h_band, lbandh)
</code></pre>

<ul>
<li>n:                 [IN] Int</li>
<li>x:                 [IN] Array{Float64, 1}</li>
<li>semibandwidth:     [IN] Int</li>
<li>h_band:            [OUT] Array{Float64, 2}</li>
<li>lbandh:            [IN] Int</li>
<li>max_semibandwidth: [OUT] Int</li>
</ul>
<p><a id='CUTEst.ubandh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64}' href='#CUTEst.ubandh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.ubandh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_band, max_semibandwidth = ubandh(nlp, x, semibandwidth, lbandh)
</code></pre>

<ul>
<li>nlp:               [IN] CUTEstModel</li>
<li>x:                 [IN] Array{Float64, 1}</li>
<li>semibandwidth:     [IN] Int</li>
<li>h_band:            [OUT] Array{Float64, 2}</li>
<li>lbandh:            [IN] Int</li>
<li>max_semibandwidth: [OUT] Int</li>
</ul>
<p><a id='CUTEst.ubandh-Tuple{Int64,Array{Float64,1},Int64,Int64}' href='#CUTEst.ubandh-Tuple{Int64,Array{Float64,1},Int64,Int64}'>#</a>
<strong><code>CUTEst.ubandh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h_band, max_semibandwidth = ubandh(n, x, semibandwidth, lbandh)
</code></pre>

<ul>
<li>n:                 [IN] Int</li>
<li>x:                 [IN] Array{Float64, 1}</li>
<li>semibandwidth:     [IN] Int</li>
<li>h_band:            [OUT] Array{Float64, 2}</li>
<li>lbandh:            [IN] Int</li>
<li>max_semibandwidth: [OUT] Int</li>
</ul>
<p><a id='CUTEst.udh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.udh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.udh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>udh!(nlp, x, lh1, h)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.udh!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.udh!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.udh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>udh!(n, x, lh1, h)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.udh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}' href='#CUTEst.udh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.udh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h = udh(nlp, x, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.udh-Tuple{Int64,Array{Float64,1},Int64}' href='#CUTEst.udh-Tuple{Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.udh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>h = udh(n, x, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.udimen-Tuple{Int64}' href='#CUTEst.udimen-Tuple{Int64}'>#</a>
<strong><code>CUTEst.udimen</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>n = udimen(input)
</code></pre>

<ul>
<li>input:   [IN] Int</li>
<li>n:       [OUT] Int</li>
</ul>
<p><a id='CUTEst.udimse-Tuple{}' href='#CUTEst.udimse-Tuple{}'>#</a>
<strong><code>CUTEst.udimse</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_val_ne, he_row_ne = udimse()
</code></pre>

<ul>
<li>ne:        [OUT] Int</li>
<li>he_val_ne: [OUT] Int</li>
<li>he_row_ne: [OUT] Int</li>
</ul>
<p><a id='CUTEst.udimsh-Tuple{}' href='#CUTEst.udimsh-Tuple{}'>#</a>
<strong><code>CUTEst.udimsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = udimsh()
</code></pre>

<ul>
<li>nnzh:    [OUT] Int</li>
</ul>
<p><a id='CUTEst.ueh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ueh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ueh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ueh!(nlp, x, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ueh!-Tuple{Int64,Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ueh!-Tuple{Int64,Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ueh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ueh!(n, x, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ueh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ueh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ueh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_row_ptr, he_val_ptr, he_row, he_val = ueh(nlp, x, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ueh-Tuple{Int64,Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ueh-Tuple{Int64,Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ueh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne, he_row_ptr, he_val_ptr, he_row, he_val = ueh(n, x, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ufn-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}' href='#CUTEst.ufn-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ufn</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = ufn(nlp, x)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
</ul>
<p><a id='CUTEst.ufn-Tuple{Int64,Array{Float64,1}}' href='#CUTEst.ufn-Tuple{Int64,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ufn</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = ufn(n, x)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
</ul>
<p><a id='CUTEst.ugr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ugr!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ugr!(nlp, x, g)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ugr!-Tuple{Int64,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ugr!-Tuple{Int64,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugr!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ugr!(n, x, g)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ugr-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}' href='#CUTEst.ugr-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g = ugr(nlp, x)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ugr-Tuple{Int64,Array{Float64,1}}' href='#CUTEst.ugr-Tuple{Int64,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugr</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g = ugr(n, x)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ugrdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.ugrdh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.ugrdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ugrdh!(nlp, x, g, lh1, h)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.ugrdh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}' href='#CUTEst.ugrdh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,2}}'>#</a>
<strong><code>CUTEst.ugrdh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ugrdh!(n, x, g, lh1, h)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.ugrdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}' href='#CUTEst.ugrdh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.ugrdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, h = ugrdh(nlp, x, lh1)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.ugrdh-Tuple{Int64,Array{Float64,1},Int64}' href='#CUTEst.ugrdh-Tuple{Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.ugrdh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, h = ugrdh(n, x, lh1)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>lh1:     [IN] Int</li>
<li>h:       [OUT] Array{Float64, 2}</li>
</ul>
<p><a id='CUTEst.ugreh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ugreh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ugreh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ugreh!(nlp, x, g, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>g:          [OUT] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ugreh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}' href='#CUTEst.ugreh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Int64,1},Array{Int64,1},Int64,Array{Int64,1},Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.ugreh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ne = ugreh!(n, x, g, lhe_ptr, he_row_ptr, he_val_ptr, lhe_row, he_row, lhe_val, he_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>g:          [OUT] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ugreh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ugreh-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ugreh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, ne, he_row_ptr, he_val_ptr, he_row, he_val = ugreh(nlp, x, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>nlp:        [IN] CUTEstModel</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>g:          [OUT] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ugreh-Tuple{Int64,Array{Float64,1},Int64,Int64,Int64,Bool}' href='#CUTEst.ugreh-Tuple{Int64,Array{Float64,1},Int64,Int64,Int64,Bool}'>#</a>
<strong><code>CUTEst.ugreh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, ne, he_row_ptr, he_val_ptr, he_row, he_val = ugreh(n, x, lhe_ptr, lhe_row, lhe_val, byrows)
</code></pre>

<ul>
<li>n:          [IN] Int</li>
<li>x:          [IN] Array{Float64, 1}</li>
<li>g:          [OUT] Array{Float64, 1}</li>
<li>ne:         [OUT] Int</li>
<li>lhe_ptr:    [IN] Int</li>
<li>he_row_ptr: [OUT] Array{Int, 1}</li>
<li>he_val_ptr: [OUT] Array{Int, 1}</li>
<li>lhe_row:    [IN] Int</li>
<li>he_row:     [OUT] Array{Int, 1}</li>
<li>lhe_val:    [IN] Int</li>
<li>he_val:     [OUT] Array{Float64, 1}</li>
<li>byrows:     [IN] Bool</li>
</ul>
<p><a id='CUTEst.ugrsh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ugrsh!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ugrsh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ugrsh!(nlp, x, g, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ugrsh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ugrsh!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ugrsh!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ugrsh!(n, x, g, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ugrsh-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}' href='#CUTEst.ugrsh-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ugrsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, nnzh, h_val, h_row, h_col = ugrsh(nlp, x)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ugrsh-Tuple{Int64,Array{Float64,1},Int64}' href='#CUTEst.ugrsh-Tuple{Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.ugrsh</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>g, nnzh, h_val, h_row, h_col = ugrsh(n, x, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.uhprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.uhprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.uhprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>uhprod!(nlp, goth, x, vector, result)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.uhprod!-Tuple{Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.uhprod!-Tuple{Int64,Bool,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.uhprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>uhprod!(n, goth, x, vector, result)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.uhprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.uhprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.uhprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = uhprod(nlp, goth, x, vector)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.uhprod-Tuple{Int64,Bool,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.uhprod-Tuple{Int64,Bool,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.uhprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>result = uhprod(n, goth, x, vector)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>goth:    [IN] Bool</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>vector:  [IN] Array{Float64, 1}</li>
<li>result:  [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.unames!-Tuple{Int64,Array{UInt8,1}}' href='#CUTEst.unames!-Tuple{Int64,Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.unames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname = unames!(n, vname)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.unames-Tuple{Int64}' href='#CUTEst.unames-Tuple{Int64}'>#</a>
<strong><code>CUTEst.unames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>pname, vname = unames(n)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>pname:   [OUT] UInt8</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.uofg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.uofg!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.uofg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = uofg!(nlp, x, g, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.uofg!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Bool}' href='#CUTEst.uofg!-Tuple{Int64,Array{Float64,1},Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.uofg!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f = uofg!(n, x, g, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.uofg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}' href='#CUTEst.uofg-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.uofg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = uofg(nlp, x, grad)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.uofg-Tuple{Int64,Array{Float64,1},Bool}' href='#CUTEst.uofg-Tuple{Int64,Array{Float64,1},Bool}'>#</a>
<strong><code>CUTEst.uofg</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>f, g = uofg(n, x, grad)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>f:       [OUT] Float64</li>
<li>g:       [OUT] Array{Float64, 1}</li>
<li>grad:    [IN] Bool</li>
</ul>
<p><a id='CUTEst.ureport!-Tuple{Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ureport!-Tuple{Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ureport!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ureport!(calls, time)
</code></pre>

<ul>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ureport!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}' href='#CUTEst.ureport!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ureport!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>ureport!(nlp, calls, time)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ureport-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.ureport-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.ureport</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>calls, time = ureport(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ureport-Tuple{}' href='#CUTEst.ureport-Tuple{}'>#</a>
<strong><code>CUTEst.ureport</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>calls, time = ureport()
</code></pre>

<ul>
<li>calls:   [OUT] Array{Float64, 1}</li>
<li>time:    [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.usetup!-Tuple{Int64,Int64,Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1}}' href='#CUTEst.usetup!-Tuple{Int64,Int64,Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.usetup!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>usetup!(input, out, io_buffer, n, x, x_l, x_u)
</code></pre>

<ul>
<li>input:     [IN] Int</li>
<li>out:       [IN] Int</li>
<li>io_buffer: [IN] Int</li>
<li>n:         [IN] Int</li>
<li>x:         [OUT] Array{Float64, 1}</li>
<li>x_l:       [OUT] Array{Float64, 1}</li>
<li>x_u:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.usetup-Tuple{Int64,Int64,Int64,Int64}' href='#CUTEst.usetup-Tuple{Int64,Int64,Int64,Int64}'>#</a>
<strong><code>CUTEst.usetup</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>x, x_l, x_u = usetup(input, out, io_buffer, n)
</code></pre>

<ul>
<li>input:     [IN] Int</li>
<li>out:       [IN] Int</li>
<li>io_buffer: [IN] Int</li>
<li>n:         [IN] Int</li>
<li>x:         [OUT] Array{Float64, 1}</li>
<li>x_l:       [OUT] Array{Float64, 1}</li>
<li>x_u:       [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ush!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ush!-Tuple{CUTEst.CUTEstModel,Array{Float64,1},Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ush!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ush!(nlp, x, h_val, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ush!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ush!-Tuple{Int64,Array{Float64,1},Int64,Array{Float64,1},Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ush!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ush!(n, x, lh, h_val, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ush-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}' href='#CUTEst.ush-Tuple{CUTEst.CUTEstModel,Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ush</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = ush(nlp, x)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ush-Tuple{Int64,Array{Float64,1},Int64}' href='#CUTEst.ush-Tuple{Int64,Array{Float64,1},Int64}'>#</a>
<strong><code>CUTEst.ush</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_val, h_row, h_col = ush(n, x, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x:       [IN] Array{Float64, 1}</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_val:   [OUT] Array{Float64, 1}</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ushp!-Tuple{CUTEst.CUTEstModel,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ushp!-Tuple{CUTEst.CUTEstModel,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ushp!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ushp!(nlp, h_row, h_col)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>nnzh:    [OUT] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ushp!-Tuple{Int64,Int64,Array{Int64,1},Array{Int64,1}}' href='#CUTEst.ushp!-Tuple{Int64,Int64,Array{Int64,1},Array{Int64,1}}'>#</a>
<strong><code>CUTEst.ushp!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh = ushp!(n, lh, h_row, h_col)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ushp-Tuple{CUTEst.CUTEstModel}' href='#CUTEst.ushp-Tuple{CUTEst.CUTEstModel}'>#</a>
<strong><code>CUTEst.ushp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_row, h_col = ushp(nlp)
</code></pre>

<ul>
<li>nlp:     [IN] CUTEstModel</li>
<li>nnzh:    [OUT] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ushp-Tuple{Int64,Int64}' href='#CUTEst.ushp-Tuple{Int64,Int64}'>#</a>
<strong><code>CUTEst.ushp</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnzh, h_row, h_col = ushp(n, lh)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>nnzh:    [OUT] Int</li>
<li>lh:      [IN] Int</li>
<li>h_row:   [OUT] Array{Int, 1}</li>
<li>h_col:   [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.ushprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.ushprod!-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ushprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = ushprod!(nlp, goth, x, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ushprod!-Tuple{Int64,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}' href='#CUTEst.ushprod!-Tuple{Int64,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1},Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ushprod!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result = ushprod!(n, goth, x, nnz_vector, index_nz_vector, vector, index_nz_result, result)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ushprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.ushprod-Tuple{CUTEst.CUTEstModel,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ushprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = ushprod(nlp, goth, x, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>nlp:             [IN] CUTEstModel</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.ushprod-Tuple{Int64,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}' href='#CUTEst.ushprod-Tuple{Int64,Bool,Array{Float64,1},Int64,Array{Int64,1},Array{Float64,1}}'>#</a>
<strong><code>CUTEst.ushprod</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>nnz_result, index_nz_result, result = ushprod(n, goth, x, nnz_vector, index_nz_vector, vector)
</code></pre>

<ul>
<li>n:               [IN] Int</li>
<li>goth:            [IN] Bool</li>
<li>x:               [IN] Array{Float64, 1}</li>
<li>nnz_vector:      [IN] Int</li>
<li>index_nz_vector: [IN] Array{Int, 1}</li>
<li>vector:          [IN] Array{Float64, 1}</li>
<li>nnz_result:      [OUT] Int</li>
<li>index_nz_result: [OUT] Array{Int, 1}</li>
<li>result:          [OUT] Array{Float64, 1}</li>
</ul>
<p><a id='CUTEst.uterminate-Tuple{}' href='#CUTEst.uterminate-Tuple{}'>#</a>
<strong><code>CUTEst.uterminate</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>uterminate()
</code></pre>

<p><a id='CUTEst.uvartype!-Tuple{Int64,Array{Int64,1}}' href='#CUTEst.uvartype!-Tuple{Int64,Array{Int64,1}}'>#</a>
<strong><code>CUTEst.uvartype!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>uvartype!(n, x_type)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x_type:  [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.uvartype-Tuple{Int64}' href='#CUTEst.uvartype-Tuple{Int64}'>#</a>
<strong><code>CUTEst.uvartype</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>x_type = uvartype(n)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>x_type:  [OUT] Array{Int, 1}</li>
</ul>
<p><a id='CUTEst.varnames!-Tuple{Int64,Array{UInt8,1}}' href='#CUTEst.varnames!-Tuple{Int64,Array{UInt8,1}}'>#</a>
<strong><code>CUTEst.varnames!</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>varnames!(n, vname)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='CUTEst.varnames-Tuple{Int64}' href='#CUTEst.varnames-Tuple{Int64}'>#</a>
<strong><code>CUTEst.varnames</code></strong> &mdash; <em>Method</em>.</p>
<pre><code>vname = varnames(n)
</code></pre>

<ul>
<li>n:       [IN] Int</li>
<li>vname:   [OUT] Array{UInt8, 1}</li>
</ul>
<p><a id='Internal-1'></a></p>
<h2 id="internal">Internal</h2>
<p><a id='CUTEst.sifdecoder-Tuple{ByteString,Vararg{Any}}' href='#CUTEst.sifdecoder-Tuple{ByteString,Vararg{Any}}'>#</a>
<strong><code>CUTEst.sifdecoder</code></strong> &mdash; <em>Method</em>.</p>
<p>Decode problem and build shared library.</p>
<p>Optional arguments are passed directly to the SIF decoder. Example:     <code>sifdecoder("DIXMAANJ", "-param", "M=30")</code>.</p>
          <aside class="copyright" role="note">
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
  <nav class="pagination" aria-label="Footer">
    <div class="previous">
      
        <a href="../home/" title="Home">
          <span class="direction">
            Previous
          </span>
          <div class="page">
            <div class="button button-previous" role="button" aria-label="Previous">
              <i class="icon icon-back"></i>
            </div>
            <div class="stretch">
              <div class="title">
                Home
              </div>
            </div>
          </div>
        </a>
      
    </div>
    <div class="next">
      
        <a href=".." title="Index">
          <span class="direction">
            Next
          </span>
          <div class="page">
            <div class="stretch">
              <div class="title">
                Index
              </div>
            </div>
            <div class="button button-next" role="button" aria-label="Next">
              <i class="icon icon-forward"></i>
            </div>
          </div>
        </a>
      
    </div>
  </nav>

            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '..';
      var repo_id  = 'JuliaSmoothOptimizers/CUTEst.jl';
    </script>
    <script src="../assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
    
      <script src="../assets/mathjaxhelper.js"></script>
    
    
  </body>
</html>