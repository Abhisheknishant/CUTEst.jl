{
    "docs": [
        {
            "location": "/", 
            "text": "CUTEst.jl documentation\n\n\nThis package provides access interfaces to \nCUTEst\n, the Constrained and Unconstrained Test Environment with safe threads for nonlinear optimization.\n\n\nThis package uses \nNLPModels.jl\n, but it also gives a different interface for accessing the problems.\n\n\n\n\nInstalling\n\n\nCurrently, this package builds its own version of CUTEst, if you have your own version of CUTEst, this will conflict with it. Check the issues for a fix, or open one for help.\n\n\nThe following commands should automatically download NLPModels.jl and CUTEst, and install them.\n\n\nPkg.clone(\nhttps://github.com/JuliaSmoothOptimizers/NLPModels.jl.git\n)\nPkg.checkout(\nNLPModels\n, \ndevelop\n)\nPkg.clone(\nhttps://github.com/JuliaSmoothOptimizers/CUTEst.jl.git\n)\nPkg.checkout(\nCUTEst\n, \ndevelop\n)\nPkg.build(\nCUTEst\n)\n\n\n\n\n\n\nUsage\n\n\nThe simples use of CUTEst is using the interface of NLPModels.jl\n\n\nusing CUTEst\n\nnlp = CUTEstModel(\nROSENBR\n)\nprintln(\nx0 = $(nlp.meta.x0)\n)\nprintln(\nfx = $( obj(nlp, nlp.meta.x0) )\n)\nprintln(\ngx = $( grad(nlp, nlp.meta.x0) )\n)\nprintln(\nHx = $( hess(nlp, nlp.meta.x0) )\n)\ncutest_finalize(nlp)\n\n\n\n\nx0 = [-1.2,1.0]\nfx = 24.199999999999996\ngx = [-215.59999999999997,-87.99999999999999]\nHx =\n    [1, 1]  =  1330.0\n    [2, 1]  =  480.0\n    [2, 2]  =  200.0\n\n\n\n\nCheck the \nAPI\n\n\nThere is also a specialized API which provides a more CUTEst-like interface, and a core API which is only a wrapper for CUTEst. The documentation of these is under construction.", 
            "title": "Home"
        }, 
        {
            "location": "/#cutestjl-documentation", 
            "text": "This package provides access interfaces to  CUTEst , the Constrained and Unconstrained Test Environment with safe threads for nonlinear optimization.  This package uses  NLPModels.jl , but it also gives a different interface for accessing the problems.", 
            "title": "CUTEst.jl documentation"
        }, 
        {
            "location": "/#installing", 
            "text": "Currently, this package builds its own version of CUTEst, if you have your own version of CUTEst, this will conflict with it. Check the issues for a fix, or open one for help.  The following commands should automatically download NLPModels.jl and CUTEst, and install them.  Pkg.clone( https://github.com/JuliaSmoothOptimizers/NLPModels.jl.git )\nPkg.checkout( NLPModels ,  develop )\nPkg.clone( https://github.com/JuliaSmoothOptimizers/CUTEst.jl.git )\nPkg.checkout( CUTEst ,  develop )\nPkg.build( CUTEst )", 
            "title": "Installing"
        }, 
        {
            "location": "/#usage", 
            "text": "The simples use of CUTEst is using the interface of NLPModels.jl  using CUTEst\n\nnlp = CUTEstModel( ROSENBR )\nprintln( x0 = $(nlp.meta.x0) )\nprintln( fx = $( obj(nlp, nlp.meta.x0) ) )\nprintln( gx = $( grad(nlp, nlp.meta.x0) ) )\nprintln( Hx = $( hess(nlp, nlp.meta.x0) ) )\ncutest_finalize(nlp)  x0 = [-1.2,1.0]\nfx = 24.199999999999996\ngx = [-215.59999999999997,-87.99999999999999]\nHx =\n    [1, 1]  =  1330.0\n    [2, 1]  =  480.0\n    [2, 2]  =  200.0  Check the  API  There is also a specialized API which provides a more CUTEst-like interface, and a core API which is only a wrapper for CUTEst. The documentation of these is under construction.", 
            "title": "Usage"
        }, 
        {
            "location": "/api/", 
            "text": "API\n\n\n\n\nNLPModels API\n\n\nobj\n\n\nobj(nlp, x)\n\n\nEvaluate $f(x)$, the objective function of \nnlp\n at \nx\n.\n\n\nobj(nlp, x)\n\n\n\n\nComputes the objective function value at x. Usage:\n\n\nf = obj(nlp, x)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nf:    [OUT] Float64\n\n\n\n\ngrad\n\n\ngrad(nlp, x)\n\n\nEvaluate $\\nabla f(x)$, the gradient of the objective function at \nx\n.\n\n\ngrad(nlp, x)\n\n\n\n\nComputes the objective gradient at x. Usage:\n\n\ng = grad(nlp, x)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\ng:    [OUT] Array{Float64, 1}\n\n\n\n\ngrad!\n\n\ngrad!(nlp, x, g)\n\n\nEvaluate $\\nabla f(x)$, the gradient of the objective function at \nx\n in place.\n\n\ngrad!(nlp, x, g)\n\n\n\n\nComputes the objective function gradient at x in place. Usage:\n\n\ngrad!(nlp, x, g)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\ng:    [OUT] Array{Float64, 1}\n\n\n\n\ncons\n\n\ncons(nlp, x)\n\n\nEvaluate $c(x)$, the constraints at \nx\n.\n\n\ncons(nlp, x, jac)\n\n\n\n\nComputes the constraint vector and, if jac is \ntrue\n, the Jacobian using the internal sparse format. Usage:\n\n\nc, J = cons(nlp, x, true)\nc = cons(nlp, x, false)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\njac:  [IN] Bool\n\n\nc:    [OUT] Array{Float64, 1}\n\n\nJ:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}\n\n\n\n\ncons(nlp, x)\n\n\n\n\nComputes the constraint vector value. Usage:\n\n\nc = cons(nlp, x)\n\n\n\n\n\n\nnlp: [IN] CUTEstModel\n\n\nx:   [IN] Array{Float64, 1}\n\n\nc:   [OUT] Array{Float64, 1}\n\n\n\n\ncons!\n\n\ncons!(nlp, x, c)\n\n\nEvaluate $c(x)$, the constraints at \nx\n in place.\n\n\ncons!(nlp, x, c)\n\n\n\n\nComputes the constraint vector value in place. Usage:\n\n\nc = cons!(nlp, x, c)\n\n\n\n\n\n\nnlp: [IN] CUTEstModel\n\n\nx:   [IN] Array{Float64, 1}\n\n\nc:   [OUT] Array{Float64, 1}\n\n\n\n\njac_coord\n\n\n(rows,cols,vals) = jac_coord(nlp, x)\n\n\nEvaluate $\\nabla c(x)$, the constraint's Jacobian at \nx\n in sparse coordinate format.\n\n\njac_coord(nlp, x)\n\n\n\n\nComputes the constraint Jacobian in coordinate format. Usage:\n\n\njrow, jcol, jval = cons_coord(nlp, x)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\njrow: [OUT] Array{Int32, 1}\n\n\njcol: [OUT] Array{Int32, 1}\n\n\njval: [OUT] Array{Float64, 1}\n\n\n\n\njac\n\n\nJx = jac(nlp, x)\n\n\nEvaluate $\\nabla c(x)$, the constraint's Jacobian at \nx\n as a sparse matrix.\n\n\njac(nlp, x)\n\n\n\n\nComputes the constraint Jacobian using the internal sparse format. Usage:\n\n\nJ = jac (nlp, x)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nJ:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}\n\n\n\n\njprod\n\n\nJv = jprod(nlp, x, v)\n\n\nEvaluate $\\nabla c(x)v$, the Jacobian-vector product at \nx\n.\n\n\njprod(nlp, x, v)\n\n\n\n\nComputes the product of the constraint Jacobian with a vector. Usage:\n\n\njv = jprod(nlp, x, v)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nv:    [IN] Array{Float64, 1}\n\n\njv:   [OUT] Array{Float64, 1}\n\n\n\n\njprod!\n\n\nJv = jprod!(nlp, x, v, Jv)\n\n\nEvaluate $\\nabla c(x)v$, the Jacobian-vector product at \nx\n in place.\n\n\njprod!(nlp, x, v, jv)\n\n\n\n\nComputes the product of the constraint Jacobian with a vector. Usage:\n\n\njprod!(nlp, x, v, jv)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nv:    [IN] Array{Float64, 1}\n\n\njv:   [OUT] Array{Float64, 1}\n\n\n\n\njtprod\n\n\nJtv = jtprod(nlp, x, v, Jtv)\n\n\nEvaluate $\\nabla c(x)^Tv$, the transposed-Jacobian-vector product at \nx\n.\n\n\njtprod(nlp, x, v)\n\n\n\n\nComputes the product of the transposed constraint Jacobian with a vector. Usage:\n\n\njtv = jtprod(nlp, x, v)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nv:    [IN] Array{Float64, 1}\n\n\njtv:  [OUT] Array{Float64, 1}\n\n\n\n\njtprod!\n\n\nJtv = jtprod!(nlp, x, v, Jtv)\n\n\nEvaluate $\\nabla c(x)^Tv$, the transposed-Jacobian-vector product at \nx\n in place.\n\n\njtprod!(nlp, x, v, jv)\n\n\n\n\nComputes the product of the transposed constraint Jacobian with a vector. Usage:\n\n\njtprod!(nlp, x, v, jv)\n\n\n\n\n\n\nnlp:  [IN] CUTEstModel\n\n\nx:    [IN] Array{Float64, 1}\n\n\nv:    [IN] Array{Float64, 1}\n\n\njtv:  [OUT] Array{Float64, 1}\n\n\n\n\nhess_coord\n\n\n(rows,cols,vals) = hess_coord(nlp, x; obj_weight=1.0, y=zeros)\n\n\nEvaluate the Lagrangian Hessian at \n(x,y)\n in sparse coordinate format, with objective function scaled by \nobj_weight\n, i.e.,\n\n\n\n\n \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x), \n\n\n\n\nwith \u03c3 = obj_weight. Only the lower triangle is returned.\n\n\nhess_coord(nlp, x, y=zeros, obj_weight=1)\n\n\n\n\nComputes the Hessian matrix in coordinate format of the Lagrangian function at x with Lagrange multipliers y for a constrained problem, or the objective function at x for an unconstrained problem. Only the lower triangle is returned. Usage:\n\n\nhrow, hcol, hval = hess_coord(nlp, x, y=zeros, obj_weight=1)\n\n\n\n\n\n\nnlp:        [IN] CUTEstModel\n\n\nx:          [IN] Array{Float64, 1}\n\n\ny:          [IN] Array{Float64, 1} (optional, =zeros)\n\n\nobj_weight: [IN] Float64 (optional, =1)\n\n\nhrow:       [OUT] Array{Int32, 1}\n\n\nhcol:       [OUT] Array{Int32, 1}\n\n\nhval:       [OUT] Array{Float64, 1}\n\n\n\n\nhess\n\n\nHx = hess(nlp, x; obj_weight=1.0, y=zeros)\n\n\nEvaluate the Lagrangian Hessian at \n(x,y)\n as a sparse matrix, with objective function scaled by \nobj_weight\n, i.e.,\n\n\n\n\n \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x), \n\n\n\n\nwith \u03c3 = obj_weight. Only the lower triangle is returned.\n\n\nhess(nlp, x, y=zeros, obj_weight=1)\n\n\n\n\nComputes the Hessian of the Lagrangian function at x with Lagrange multipliers y for a constrained problem or the Hessian of the objective function at x for an unconstrained problem. Only the lower triangle is returned. Usage:\n\n\nH = hess(nlp, x, y=zeros, obj_weight=1)\n\n\n\n\n\n\nnlp:        [IN] CUTEstModel\n\n\nx:          [IN] Array{Float64, 1}\n\n\ny:          [IN] Array{Float64, 1} (optional, =zeros)\n\n\nobj_weight: [IN] Float64 (optional, =1)\n\n\nH:          [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64, Int64}\n\n\n\n\nhprod\n\n\nHv = hprod(nlp, x, v; obj_weight=1.0, y=zeros)\n\n\nEvaluate the product of the Lagrangian Hessian at \n(x,y)\n with the vector \nv\n, with objective function scaled by \nobj_weight\n, i.e.,\n\n\n\n\n \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x), \n\n\n\n\nwith \u03c3 = obj_weight.\n\n\nhprod(nlp, x, v, y=zeros, obj_weight=1)\n\n\n\n\nComputes the matrix-vector product between the Hessian matrix and the vector v. If the problem is constrained, the Hessian is of the Lagrangian function at x with Lagrange multipliers y, otherwise the Hessian is of the objective function at x. Usage:\n\n\nHv = hprod(nlp, x, v, y=zeros, obj_weight=1)\n\n\n\n\n\n\nnlp:        [IN] CUTEstModel\n\n\nx:          [IN] Array{Float64, 1}\n\n\nv:          [IN] Array{Float64, 1}\n\n\ny:          [IN] Array{Float64, 1} (optional, =zeros)\n\n\nobj_weight: [IN] Float64 (optional, =1)\n\n\nHv:         [OUT] Array{Float64, 1}\n\n\n\n\nhprod!\n\n\nHv = hprod!(nlp, x, v, Hv; obj_weight=1.0, y=zeros)\n\n\nEvaluate the product of the Lagrangian Hessian at \n(x,y)\n with the vector \nv\n in place, with objective function scaled by \nobj_weight\n, i.e.,\n\n\n\n\n \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x), \n\n\n\n\nwith \u03c3 = obj_weight.\n\n\nhprod!(nlp, x, v, Hv, y=zeros, obj_weight=1)\n\n\n\n\nComputes the matrix-vector product between the Hessian matrix and the vector v and write the result to vector Hv. If the problem is constrained, the Hessian is of the Lagrangian function at x with Lagrange multipliers y, otherwise the Hessian is of the objective function at x. Usage:\n\n\nhprod!(nlp, x, v, Hv, y=zeros, obj_weight=1)\n\n\n\n\n\n\nnlp:        [IN] CUTEstModel\n\n\nx:          [IN] Array{Float64, 1}\n\n\nv:          [IN] Array{Float64, 1}\n\n\ny:          [IN] Array{Float64, 1} (optional, =zeros)\n\n\nobj_weight: [IN] Float64 (optional, =1)\n\n\nHv:         [OUT] Array{Float64, 1}\n\n\n\n\nNLPtoMPB\n\n\nmp = NLPtoMPB(nlp, solver)\n\n\nReturn a \nMathProgBase\n model corresponding to this model. \nsolver\n should be a solver instance, e.g., \nIpoptSolver()\n. Currently, all models are treated as nonlinear models.\n\n\nReturn a \nMathProgBase\n model corresponding to a \nCUTEstModel\n. The second argument should be a solver instance, e.g., \nIpoptSolver()\n. Currently, all models are treated as nonlinear models.\n\n\nreset!\n\n\n`reset!(nlp)\n\n\nReset evaluation count in \nnlp\n\n\nreset!(counters)\n\n\nReset evaluation counters", 
            "title": "API"
        }, 
        {
            "location": "/api/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/api/#nlpmodels-api", 
            "text": "", 
            "title": "NLPModels API"
        }, 
        {
            "location": "/api/#obj", 
            "text": "obj(nlp, x)  Evaluate $f(x)$, the objective function of  nlp  at  x .  obj(nlp, x)  Computes the objective function value at x. Usage:  f = obj(nlp, x)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  f:    [OUT] Float64", 
            "title": "obj"
        }, 
        {
            "location": "/api/#grad", 
            "text": "grad(nlp, x)  Evaluate $\\nabla f(x)$, the gradient of the objective function at  x .  grad(nlp, x)  Computes the objective gradient at x. Usage:  g = grad(nlp, x)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  g:    [OUT] Array{Float64, 1}", 
            "title": "grad"
        }, 
        {
            "location": "/api/#grad_1", 
            "text": "grad!(nlp, x, g)  Evaluate $\\nabla f(x)$, the gradient of the objective function at  x  in place.  grad!(nlp, x, g)  Computes the objective function gradient at x in place. Usage:  grad!(nlp, x, g)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  g:    [OUT] Array{Float64, 1}", 
            "title": "grad!"
        }, 
        {
            "location": "/api/#cons", 
            "text": "cons(nlp, x)  Evaluate $c(x)$, the constraints at  x .  cons(nlp, x, jac)  Computes the constraint vector and, if jac is  true , the Jacobian using the internal sparse format. Usage:  c, J = cons(nlp, x, true)\nc = cons(nlp, x, false)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  jac:  [IN] Bool  c:    [OUT] Array{Float64, 1}  J:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}   cons(nlp, x)  Computes the constraint vector value. Usage:  c = cons(nlp, x)   nlp: [IN] CUTEstModel  x:   [IN] Array{Float64, 1}  c:   [OUT] Array{Float64, 1}", 
            "title": "cons"
        }, 
        {
            "location": "/api/#cons_1", 
            "text": "cons!(nlp, x, c)  Evaluate $c(x)$, the constraints at  x  in place.  cons!(nlp, x, c)  Computes the constraint vector value in place. Usage:  c = cons!(nlp, x, c)   nlp: [IN] CUTEstModel  x:   [IN] Array{Float64, 1}  c:   [OUT] Array{Float64, 1}", 
            "title": "cons!"
        }, 
        {
            "location": "/api/#jac_coord", 
            "text": "(rows,cols,vals) = jac_coord(nlp, x)  Evaluate $\\nabla c(x)$, the constraint's Jacobian at  x  in sparse coordinate format.  jac_coord(nlp, x)  Computes the constraint Jacobian in coordinate format. Usage:  jrow, jcol, jval = cons_coord(nlp, x)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  jrow: [OUT] Array{Int32, 1}  jcol: [OUT] Array{Int32, 1}  jval: [OUT] Array{Float64, 1}", 
            "title": "jac_coord"
        }, 
        {
            "location": "/api/#jac", 
            "text": "Jx = jac(nlp, x)  Evaluate $\\nabla c(x)$, the constraint's Jacobian at  x  as a sparse matrix.  jac(nlp, x)  Computes the constraint Jacobian using the internal sparse format. Usage:  J = jac (nlp, x)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  J:    [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}", 
            "title": "jac"
        }, 
        {
            "location": "/api/#jprod", 
            "text": "Jv = jprod(nlp, x, v)  Evaluate $\\nabla c(x)v$, the Jacobian-vector product at  x .  jprod(nlp, x, v)  Computes the product of the constraint Jacobian with a vector. Usage:  jv = jprod(nlp, x, v)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  v:    [IN] Array{Float64, 1}  jv:   [OUT] Array{Float64, 1}", 
            "title": "jprod"
        }, 
        {
            "location": "/api/#jprod_1", 
            "text": "Jv = jprod!(nlp, x, v, Jv)  Evaluate $\\nabla c(x)v$, the Jacobian-vector product at  x  in place.  jprod!(nlp, x, v, jv)  Computes the product of the constraint Jacobian with a vector. Usage:  jprod!(nlp, x, v, jv)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  v:    [IN] Array{Float64, 1}  jv:   [OUT] Array{Float64, 1}", 
            "title": "jprod!"
        }, 
        {
            "location": "/api/#jtprod", 
            "text": "Jtv = jtprod(nlp, x, v, Jtv)  Evaluate $\\nabla c(x)^Tv$, the transposed-Jacobian-vector product at  x .  jtprod(nlp, x, v)  Computes the product of the transposed constraint Jacobian with a vector. Usage:  jtv = jtprod(nlp, x, v)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  v:    [IN] Array{Float64, 1}  jtv:  [OUT] Array{Float64, 1}", 
            "title": "jtprod"
        }, 
        {
            "location": "/api/#jtprod_1", 
            "text": "Jtv = jtprod!(nlp, x, v, Jtv)  Evaluate $\\nabla c(x)^Tv$, the transposed-Jacobian-vector product at  x  in place.  jtprod!(nlp, x, v, jv)  Computes the product of the transposed constraint Jacobian with a vector. Usage:  jtprod!(nlp, x, v, jv)   nlp:  [IN] CUTEstModel  x:    [IN] Array{Float64, 1}  v:    [IN] Array{Float64, 1}  jtv:  [OUT] Array{Float64, 1}", 
            "title": "jtprod!"
        }, 
        {
            "location": "/api/#hess_coord", 
            "text": "(rows,cols,vals) = hess_coord(nlp, x; obj_weight=1.0, y=zeros)  Evaluate the Lagrangian Hessian at  (x,y)  in sparse coordinate format, with objective function scaled by  obj_weight , i.e.,    \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x),    with \u03c3 = obj_weight. Only the lower triangle is returned.  hess_coord(nlp, x, y=zeros, obj_weight=1)  Computes the Hessian matrix in coordinate format of the Lagrangian function at x with Lagrange multipliers y for a constrained problem, or the objective function at x for an unconstrained problem. Only the lower triangle is returned. Usage:  hrow, hcol, hval = hess_coord(nlp, x, y=zeros, obj_weight=1)   nlp:        [IN] CUTEstModel  x:          [IN] Array{Float64, 1}  y:          [IN] Array{Float64, 1} (optional, =zeros)  obj_weight: [IN] Float64 (optional, =1)  hrow:       [OUT] Array{Int32, 1}  hcol:       [OUT] Array{Int32, 1}  hval:       [OUT] Array{Float64, 1}", 
            "title": "hess_coord"
        }, 
        {
            "location": "/api/#hess", 
            "text": "Hx = hess(nlp, x; obj_weight=1.0, y=zeros)  Evaluate the Lagrangian Hessian at  (x,y)  as a sparse matrix, with objective function scaled by  obj_weight , i.e.,    \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x),    with \u03c3 = obj_weight. Only the lower triangle is returned.  hess(nlp, x, y=zeros, obj_weight=1)  Computes the Hessian of the Lagrangian function at x with Lagrange multipliers y for a constrained problem or the Hessian of the objective function at x for an unconstrained problem. Only the lower triangle is returned. Usage:  H = hess(nlp, x, y=zeros, obj_weight=1)   nlp:        [IN] CUTEstModel  x:          [IN] Array{Float64, 1}  y:          [IN] Array{Float64, 1} (optional, =zeros)  obj_weight: [IN] Float64 (optional, =1)  H:          [OUT] Base.SparseMatrix.SparseMatrixCSC{Float64, Int64}", 
            "title": "hess"
        }, 
        {
            "location": "/api/#hprod", 
            "text": "Hv = hprod(nlp, x, v; obj_weight=1.0, y=zeros)  Evaluate the product of the Lagrangian Hessian at  (x,y)  with the vector  v , with objective function scaled by  obj_weight , i.e.,    \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x),    with \u03c3 = obj_weight.  hprod(nlp, x, v, y=zeros, obj_weight=1)  Computes the matrix-vector product between the Hessian matrix and the vector v. If the problem is constrained, the Hessian is of the Lagrangian function at x with Lagrange multipliers y, otherwise the Hessian is of the objective function at x. Usage:  Hv = hprod(nlp, x, v, y=zeros, obj_weight=1)   nlp:        [IN] CUTEstModel  x:          [IN] Array{Float64, 1}  v:          [IN] Array{Float64, 1}  y:          [IN] Array{Float64, 1} (optional, =zeros)  obj_weight: [IN] Float64 (optional, =1)  Hv:         [OUT] Array{Float64, 1}", 
            "title": "hprod"
        }, 
        {
            "location": "/api/#hprod_1", 
            "text": "Hv = hprod!(nlp, x, v, Hv; obj_weight=1.0, y=zeros)  Evaluate the product of the Lagrangian Hessian at  (x,y)  with the vector  v  in place, with objective function scaled by  obj_weight , i.e.,    \\nabla^2L(x,y) = \\sigma * \\nabla^2 f(x) + \\sum_{i=1}^m y_i\\nabla^2 c_i(x),    with \u03c3 = obj_weight.  hprod!(nlp, x, v, Hv, y=zeros, obj_weight=1)  Computes the matrix-vector product between the Hessian matrix and the vector v and write the result to vector Hv. If the problem is constrained, the Hessian is of the Lagrangian function at x with Lagrange multipliers y, otherwise the Hessian is of the objective function at x. Usage:  hprod!(nlp, x, v, Hv, y=zeros, obj_weight=1)   nlp:        [IN] CUTEstModel  x:          [IN] Array{Float64, 1}  v:          [IN] Array{Float64, 1}  y:          [IN] Array{Float64, 1} (optional, =zeros)  obj_weight: [IN] Float64 (optional, =1)  Hv:         [OUT] Array{Float64, 1}", 
            "title": "hprod!"
        }, 
        {
            "location": "/api/#nlptompb", 
            "text": "mp = NLPtoMPB(nlp, solver)  Return a  MathProgBase  model corresponding to this model.  solver  should be a solver instance, e.g.,  IpoptSolver() . Currently, all models are treated as nonlinear models.  Return a  MathProgBase  model corresponding to a  CUTEstModel . The second argument should be a solver instance, e.g.,  IpoptSolver() . Currently, all models are treated as nonlinear models.", 
            "title": "NLPtoMPB"
        }, 
        {
            "location": "/api/#reset", 
            "text": "`reset!(nlp)  Reset evaluation count in  nlp  reset!(counters)  Reset evaluation counters", 
            "title": "reset!"
        }
    ]
}